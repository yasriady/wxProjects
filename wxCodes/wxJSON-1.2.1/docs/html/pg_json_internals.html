<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>wxJSON: wxJSON - The wxWidgets implementation of JSON</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="pg_json_internals">wxJSON internals </a></h1><ul>
<li><a class="el" href="pg_json_internals.html#json_internals_intro">Introduction</a> </li>
<li><a class="el" href="pg_json_internals.html#json_internals_cow">wxJSON internals: reference counting</a> </li>
<li><a class="el" href="pg_json_internals.html#json_internals_cstring">wxJSON internals: the C string type</a> </li>
<li><a class="el" href="pg_json_internals.html#json_internals_integer">64-bits and 32-bits integers</a> </li>
<li><a class="el" href="pg_json_internals.html#json_internals_array">The array of values.</a> </li>
<li><a class="el" href="pg_json_internals.html#json_internals_map">The map of key/value pairs.</a>. </li>
<li><a class="el" href="pg_json_internals.html#json_internals_compare">The comparison function and operator</a> </li>
<li><a class="el" href="pg_json_internals.html#json_comment">C/C++ comments in JSON text</a> </li>
<li><a class="el" href="pg_json_internals.html#json_internals_reader">The wxJSONReader class</a> </li>
<li><a class="el" href="pg_json_internals.html#json_internals_writer">The wxJSONWriter class</a></li>
</ul>
<h2><a class="anchor" name="json_internals_intro">
Introduction</a></h2>
The <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class is much like a <b>variant</b> type which can hold various types (see the documentation of the wxWidgets' <b>wxVariant</b> class). The JSON value class is a bit different from wxVariant because it cannot hold whatever type you want but only the following:<p>
<ul>
<li>a NULL value </li>
<li>a signed integer </li>
<li>an unsigned integer </li>
<li>a double </li>
<li>a boolean </li>
<li>a C string </li>
<li>a wxString object </li>
<li>an array of <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> objects </li>
<li>an map of key/value pairs where the <em>key</em> is a wxString and the <em>value</em> can be any <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object.</li>
</ul>
The type of the JSON value contained in a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object is an enumerated constant of type wxJSONType. Starting from version 0.5 the <b>wxJSON</b> library supports 64-bits integers which introduced new JSON types. For more info see <a class="el" href="pg_json_internals.html#json_internals_integer">64-bits and 32-bits integers</a>.<p>
There is no need to specify the type of a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object: it is automatically set when you construct the object or when a value is assigned to it. For example:<p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v;            <span class="comment">// a 'null' value</span>
 <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 10 );     <span class="comment">// signed integer type</span>
 <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2( 12.90);   <span class="comment">// double type</span>
 v1 = <span class="stringliteral">"some string"</span>;       <span class="comment">// now 'v1' is of type string</span>

 <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v3;           <span class="comment">// a 'null' value</span>
 v3.<a class="code" href="classwxJSONValue.html#9ae9caef81e6e2f5b10853cdcbccb33c" title="Append the specified value in the array.">Append</a>( 10 );          <span class="comment">// 'v3' is now of type wxJSONTYPE_ARRAY</span>
</pre></div><p>
The only exception to this is when you want to set the wxJSONTYPE_INVALID. Note that you should cast the wxJSONTYPE_INVALID constant to a wxJSONType type because some compilers may assume the constant value to be an <b>int:</b> <p>
<div class="fragment"><pre class="fragment"> <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> value( (<a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592" title="The type of the value held by the wxJSONRefData class.">wxJSONType</a>) <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592833e80f3431014a55f9076223fbebd69">wxJSONTYPE_INVALID</a> );
</pre></div><p>
<dl class="user" compact><dt><b>The wxJSONRefData structure</b></dt><dd></dd></dl>
The <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class does not actually hold data. It only holds a pointer to a data structure of type <a class="el" href="classwxJSONRefData.html" title="The reference counted JSON value data (internal use).">wxJSONRefData</a>. The latter actually holds data: the type of the value, the value itself, comments, etc.. This is used to implement <em>copy-on-write</em> (see <a class="el" href="pg_json_internals.html#json_internals_cow">wxJSON internals: reference counting</a> for details).<p>
All data is stored in the <a class="el" href="classwxJSONRefData.html" title="The reference counted JSON value data (internal use).">wxJSONRefData</a> class which is just a simple structure: the class does not define an interface for accessing data: it only defines the data members and the ctors and dtor. The interface is totally defined in the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class which, in turn, does not contain any data (with the exception of the pointer to referenced data).<p>
The data structure holds the type of the JSON value, the JSON value itself, the comment lines, if any, etc. To know more about the individual data member defined in the class see the documentation of <a class="el" href="classwxJSONRefData.html" title="The reference counted JSON value data (internal use).">wxJSONRefData</a>. The data structure holds data in two different modes:<p>
<ul>
<li>in a <b>union</b> for primitive types </li>
<li>in data members for complex types such as strings, arrays and maps</li>
</ul>
The union is defined as follows:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">union </span><a class="code" href="unionwxJSONValueHolder.html" title="The actual value held by the wxJSONValue class (internal use).">wxJSONValueHolder</a>  {
    <span class="keywordtype">int</span>              m_valInt;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>     m_valUInt;
    <span class="keywordtype">short</span> <span class="keywordtype">int</span>        m_valShort;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>   m_valUShort;
    <span class="keywordtype">long</span> <span class="keywordtype">int</span>         m_valLong;
    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>    m_valULong;
    <span class="keywordtype">double</span>           m_valDouble;
    <span class="keyword">const</span> wxChar*    m_valCString;
    <span class="keywordtype">bool</span>             m_valBool;

<span class="preprocessor"> #if defined( wxJSON_64BIT_INT )</span>
<span class="preprocessor"></span>    wxInt64          m_valInt64;
    wxUint64         m_valUInt64;
<span class="preprocessor"> #endif</span>
<span class="preprocessor">  };</span>
</pre></div><p>
The <a class="el" href="classwxJSONRefData.html" title="The reference counted JSON value data (internal use).">wxJSONRefData</a> structure also holds the three complex objects that represent the three JSON value types: strings, arrays and objects (this is referred to JSON objets, not C++ class's instances):<p>
<div class="fragment"><pre class="fragment">    wxString             m_valString;
    <a class="code" href="jsonval_8h.html#50f303b311b8528404e9eadcf1c65e2f">wxJSONInternalArray</a>  m_valArray;
    <a class="code" href="jsonval_8h.html#fd467c09a9467362fe6ede843fa5333a">wxJSONInternalMap</a>    m_valMap;
</pre></div><p>
Note that primitive types are stored in a union and not in a structure: this means that when you store a value in one of the data member, all other are also affected. I will explain more clearly with an example:<p>
integers are stored using the most wide storage size; (unsigned) <b>long</b> <b>int</b> by default and <b>wx(U)Int64</b> on platforms that support 64-bits integers. (to know more about 64-bits integer support read <a class="el" href="pg_json_internals.html#json_internals_integer">64-bits and 32-bits integers</a>). So if you store a <b>int</b> data type of value -1, all other data member will get a value that depends on the data type stored. Below you find an hardcopy of the memory dump of a JSON value object which was assigned the integer value of -1:<p>
<div align="center">
<img src="images/intern01.png" alt="intern01.png">
</div>
<p>
A value of -1 is stored as all binary '1' in the union but the value returned by the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class depends on the type you want. In other words, if you get the value as an integer you get -1 but if you get the value as an <b>unsigned</b> integer you get different values depending on the size of the requested type. Also note that when the same value is returned as a double, the <a class="el" href="classwxJSONValue.html#abfbf017df18677aa74d90bb36c6bb14" title="Return the stored value as a double.">wxJSONValue::AsDouble()</a> function does not promote the <b>int</b> to a <b>double:</b> the function just returns the bits as they are stored and interpreted as a double thus returning a <em>NaN</em>.<h2><a class="anchor" name="json_internals_cow">
wxJSON internals: reference counting</a></h2>
Starting from version 0.4.0 the internal representation of a JSON value has totally changed because of the implementation of the <em>reference</em> <em>counting</em> tecnique also known as <em>copy-on-write</em>. Now the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class does not actually contain any data: every instance of this class holds a pointer to the actual data structure defined in the <a class="el" href="classwxJSONRefData.html" title="The reference counted JSON value data (internal use).">wxJSONRefData</a> class. The structure contains a special data member that counts the number of instances of <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> objects that share the data.<p>
If you look at the example memory dump seen above, you will note the <code><a class="el" href="classwxJSONValue.html#9dd9d611760a3cf6febb991a0c81fc5c" title="the referenced data">wxJSONValue::m_refData</a></code> data member that points to the actual data structure and the <code><a class="el" href="classwxJSONRefData.html#7bda10b1fd11f0042c1d04ecb643c386" title="the references count">wxJSONRefData::m_refCount</a></code> data member that counts how many JSON value objects share the data structure (one, in the example).<p>
Reference counting is very simple: if you copy an instance of a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object, the data contained in the <a class="el" href="classwxJSONRefData.html" title="The reference counted JSON value data (internal use).">wxJSONRefData</a> structure is not really copied but, instead, it is shared by the two JSON value objects which data pointer points to the same memory area. Here is an example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 12 );
  wxJSONvalue v2( v1 );
</pre></div><p>
<div align="center">
<img src="images/cow02.png" alt="cow02.png">
</div>
<p>
Reference counting is implemented in many wxWidget's classes such as wxBitmap, wxImage, etc but the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class is a bit different because objects of this class may contain other <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> objects and they can be nested to a virtually infinite level. This cause references to not being propagated in the hierarchy. Also, because values are accessed using the subscript operators - which are <b>non-const</b> functions - COW for <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> objects is not as efficient as we may expect.<p>
In the following paragraphs I try to explain what happens when you make a copy of a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> and then call some non-const functions on one of the two instances.<h3><a class="anchor" name="json_internals_cow_array">
Making a copy of an array type.</a></h3>
In the following example I create an array type and set a value to the fourth element. The subscript operator automatically creates the first for elements and initializes them to a <b>null</b> value. Then, the integer value is assigned to the fourth element by the assignment operator. Note that the first three array's element share the same data: this is because the subscript operator automatically creates all instances of the items until the requested index. Needed items are created by copying (using COW) a temporary NULL JSON value:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1;
  v1[3] = 12;           <span class="comment">// set the value of the fourth item</span>
</pre></div><p>
<div align="center">
<img src="images/cow08.png" alt="cow08.png">
</div>
<p>
Writing the value to a JSON text document we get the following:<p>
<div class="fragment"><pre class="fragment"> [
    null,
    null,
    null,
    12
 ]
</pre></div><p>
Now copy the <b>v1</b> JSON value to a <b>v3</b> value. Note that the root JSON data structure is shared by the two instances.<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1;
  v1[3] = 12;           <span class="comment">// set the value of the fourth item</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v3(v1);   <span class="comment">// make a copy of 'v1'</span>
</pre></div><p>
<div align="center">
<img src="images/cow09.png" alt="cow09.png">
</div>
<p>
We already noted that the three <b>null</b> values in the array share the same data structure but because the root value is shared we only have a reference count of THREE for the NULL values. In fact, the data is shared by SIX JSON value objects: 3 items in <b>v1</b> plus 3 items in <b>v3</b> (six values in total) but as the parent object is shared, the <a class="el" href="classwxJSONRefData.html#7bda10b1fd11f0042c1d04ecb643c386" title="the references count">wxJSONRefData::m_refCount</a> data member only counts 3 shares.<h3><a class="anchor" name="json_internals_cow_write">
Writing to a shared data</a></h3>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1;
  v1[3] = 12;           <span class="comment">// set the value of the fourth item</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v3(v1);   <span class="comment">// makes a copy of 'v1'</span>

  v3[1] = 2;            <span class="comment">// change the value of the second array's element</span>
</pre></div><p>
When we change a value of an array's element we would expect that a real copy of only that array's element is done and it is assigned the new value.<p>
We are wrong. In fact, the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object makes a copy of the whole root object <b>v3</b>. Why? The answer is simple: the first impression is that the assignment operator is called for the second array element of <b>v3</b> and this would cause a real copy of that array's element. In reality, <b>before</b> calling the <b>operator=</b> memberfunction the code fragment seen above must return a reference to the second element of <b>v3's</b> array. This reference is returned by the <b>operator</b>[] (the subscript operator) which is itself a <b>non-const</b> memberfunction. So, the subscript operator of the root value object makes a real copy of the referenced data. All array's elements are copied from <b>v1's</b> instance to <b>v3</b>. You may notice from the memory dump that the copy of elements is not a real copy but it uses COW. Below you find the memory dump of the two object after we had changed one array's element. As you can see, each root value has now an exclusive copy of the array:<p>
<div align="center">
<img src="images/cow10.png" alt="cow10.png">
</div>
<p>
In order to avoid the copy of the top-level array type we have had to use a <em>const</em> member function to access the second array's element. Note that we cannot use the <a class="el" href="classwxJSONValue.html#7c3070f8cb80e599609461eb679ceec3" title="Return the item at the specified index.">wxJSONValue::ItemAt()</a> function because this function returns a copy of the data not a reference to it:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1;
  v1[3] = 12;           <span class="comment">// set the value of the fourth item</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2(v1);   <span class="comment">// makes a copy of 'v1'</span>

  <span class="comment">// does not work!!! what we do is to change a temporary copy</span>
  <span class="comment">// of the second array's element</span>
  v2.ItemAt( 1 ) = <span class="stringliteral">"value changed"</span>;
</pre></div><p>
The only suitable function is the <a class="el" href="classwxJSONValue.html#7b0d808f369ae2de942acccfb7aacabb" title="Find an element.">wxJSONValue::Find()</a> function which is, unfortunately, protected so it cannot be called from outside the class.<p>
Another drawback of using non-const subscript operators is that the copy operation is done also when we do not write to the JSON value object but also when we read from it. This is an example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1;
  v1[3] = 12;           <span class="comment">// set the value of the fourth item</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2(v1);   <span class="comment">// makes a copy of 'v1'</span>

  <span class="keywordtype">int</span> i = v1[3].<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();   <span class="comment">// read from 'v1'</span>
</pre></div><p>
Because the <b>operator</b>[] memberfunction is non-const, the read operation causes the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class to make an exclusive copy of shared data even when the access to the value is only for read purposes. The good news is that we can use <a class="el" href="classwxJSONValue.html#7c3070f8cb80e599609461eb679ceec3" title="Return the item at the specified index.">wxJSONValue::ItemAt()</a> in this case thus avoiding the copy operation of the shared data ( OK, tested see <code>samples/test11.cpp</code> function <code>Test51()</code> )<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1;
  v1[3] = 12;           <span class="comment">// set the value of the fourth item</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2(v1);   <span class="comment">// makes a copy of 'v1'</span>

  <span class="keywordtype">int</span> i = v1.<a class="code" href="classwxJSONValue.html#7c3070f8cb80e599609461eb679ceec3" title="Return the item at the specified index.">ItemAt</a>( 3 ).<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();
</pre></div><p>
The problem is that we can use <code>ItemAt()</code> for only one level in the JSON value's hierarchy.<p>
So is COW totally useless? No, it is not!<p>
Even when using subscripts operators, the real copy of shared data is done only until the parent of the requested level: every other JSON value objects of the same level and of inferior levels are not really copied: COW is used for all of them. In the following image you see that in the above example of a four element's array, the JSON array value <b>v1</b> is copied to <b>v3</b> but the individual items are not really copied because 3 items of <b>v1</b> and 2 items of <b>v3</b> refer to the same referenced data (the NULL value):<p>
<div align="center">
<img src="images/cow11.png" alt="cow11.png">
</div>
<p>
In this example, the array's items are NULL values, thus the time that was saved in the COW in not really much but remember that an array's item may contain another array which may contain one or more key/value hashmaps, which may contain one or more array which .... and so on.<h2><a class="anchor" name="json_internals_cstring">
wxJSON internals: the C string type</a></h2>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>( <span class="keyword">const</span> wxChar* str );
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>( <span class="keyword">const</span> wxString&amp; str );
</pre></div><p>
You may ask yourself why there are 2 different constructors for strings. For convenience, you may think, in order to save an implicit conversion from <b>const</b> <b>wxChar*</b> to <b>wxString</b>. The answer is: NO. The two constructors store the string in a very different way.<p>
Both ctors store strings and they could be stored just as <b>wxString</b> objects. In fact, this is the default behaviour of the class if the <code>WXJSON_USE_CSTRING</code> macro is not defined.<p>
If this macro is defined, however, the first ctor stores the pointer in the <code><a class="el" href="classwxJSONRefData.html" title="The reference counted JSON value data (internal use).">wxJSONRefData</a></code> structure assuming that the string is statically allocated and it does NOT copy the string. This behaviour saves a string's copy which can be time-consuming but, on the other hand, you must be sure that the pointed-to buffer is not freed / deallocated for the lifetime of the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object (this is always true for static strings). The following code fragment is an example on how to use the static string type:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> aString( _T(<span class="stringliteral">"This is a static string"</span>));
</pre></div><p>
The code above is correct, because the pointed-to string is really statically allocated (and, on most platforms, static strings are allocated in the code segment so that they cannot be changed for the lifetime of the application).<p>
The following code is not correct and it would probably result in a SEGFAULT when you try to access the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> data. The problem is that the string is constructed on the stack which will be deallocated when the function returns. So, the returned JSON object contains a pointer to a deallocated memory area.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Example 1</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> MyFunction()
  {
    <span class="keywordtype">char</span> buffer[128];
    snprintf( buffer, 128, <span class="stringliteral">"This is a string constructed on the stack"</span>);
    <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> aString( buffer );
    <span class="keywordflow">return</span> aString;
  }
</pre></div><p>
The code above should be written as follows:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// Example 2</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> MyFunction()
  {
    <span class="keywordtype">char</span> buffer[128];
    snprintf( buffer, 128, <span class="stringliteral">"This is a string constructed on the stack"</span>);
    <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> aString( wxString( buffer));
    <span class="keywordflow">return</span> aString;
  }
</pre></div><p>
Now it is correct because the <b>wxString</b> object holds a <b>copy</b> of the <code>buffer</code> memory area. Note that if the <code>WXJSON_USE_CSTRING</code> macro is not defined, there is no need to actually construct a temporary <b>wxString</b> object in order to force the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class to create an instance of the wxString object: it is automaticlly created by the wxJSONValue( const wxChar*) ctor. This mean that you can use use the code in <b>Example</b> <b>1</b> without worry about C-strings. By default, the wxJSON_USE_CSTRING macro is <b>not</b> defined.<p>
If your application uses many static strings that never changes, you can save time by defining the symbol when compiling the wxJSON library<p>
<b>NOTES:</b> the static C-string type value is, probably, useless and, in fact, it is never used in <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> by default. The C string value is useless because the only reason for using it is speed: time is saved when no string-copy operation is performed. But the <b>wxString</b> object uses <em>copy-on-write</em> to avoid unnecessary copies so it is much more wisely (and SAFE) to never use C-strings.<h2><a class="anchor" name="json_internals_integer">
64-bits and 32-bits integers</a></h2>
Starting from version 0.5, the <em>wxJSON</em> library supports 64-bits integers but only on those platforms that have native support for 64-bits integers such as, for example, Win32 and GNU/Linux.<p>
Starting from version 1.0 the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> also handles <b>long</b> <b>int</b> and <b>short</b> <b>int</b> data types.<p>
By default, the library checks if the <b>wxLongLong_t</b> macro is defined by <b>wxWidgets</b> and, if it is, the library enables 64-bits integer support. The <b>wxLongLong_t</b> macro is the wxWidget's platform independent data type for representing a 64-bits integer and it is defined by the GUI framework as a placeholder for the underlying compiler / platform specific data type: <b>__int64</b> on Windows and <b>long</b> <b>long</b> on GNU/Linux systems. To know more about the wxWidget's 64-bits integer stuff read the documentation of the <b>wxLongLong</b> class. If the system / platform do not support 64-bits integers, integer values are stored in a:<p>
<ul>
<li>(unsigned) <b>long</b> <b>int</b> (32-bit) data type in wxJSON versions 1.0 and above </li>
<li>(unsigned) <b>int</b> data type in all 0.x versions.</li>
</ul>
The user can disable 64-bits integer support by defining the:<p>
<div class="fragment"><pre class="fragment">  wxJSON_NO_64BIT_INT
</pre></div><p>
macro in the <code><a class="el" href="json__defs_8h.html">include/wx/json_defs.h</a></code> header file (just uncomment the line where the macro is defined).<p>
All integer values are stored in the widest storage size: <b>wx(U)int64</b> or <b>long</b> <b>int</b> depending the platform. The <code>m_type</code> data member of the JSON value is set to the generic integer type: wxJSONTYPE_INT or wxJSONTYPE_UINT regardless its size: in other words, no matter the type of the original value: the only thing that matters is the sign of the value: signed or unsigned.<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> i( 100)               <span class="comment">// an int</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> l( (<span class="keywordtype">short</span>) 100)       <span class="comment">// a short int</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> l( (<span class="keywordtype">long</span>) 100)        <span class="comment">// a long int</span>
  wxJSONvalue i64( (wxInt64) 100 ); <span class="comment">// a long long int</span>
</pre></div><p>
All the above integer values are stored in the <code><a class="el" href="unionwxJSONValueHolder.html#357ce7555bed8b00fce3780c776e69fb">wxJSONValueHolder::m_valInt64</a></code> or in the <code><a class="el" href="unionwxJSONValueHolder.html#ee26cc7170b63dc3784fa8a9ecba445a">wxJSONValueHolder::m_valLong</a></code> data member. The JSON value type is set to wxJSONTYPE_INT for all cases. As the storage area of all primitive types is the same (it is an union) it is very easy to return an integer value in different sizes provided that the requested integer type has sufficient bits to store the value.<p>
How can the user know the storage needs of a integer data type? First of all you have to ask yourself if you really need to know this information. In other words, if your application only uses the <b>int</b> data type (for integers) and it only reads its own JSON data file, it is improbable that an integer value stored in the JSON value class will hold other than an <b>int</b>. On the other hand, if your application communicate with other applications over a network connection, it may be possible that the JSON value class holds integers which are so large that they cannot fit in a simple <b>int</b> data type.<p>
In order to know the storage needs of the value stored in the class you call the <code><a class="el" href="classwxJSONValue.html#464f3962a62fc31bd9b096ff7401495a" title="Return the type of the value stored in the object.">wxJSONValue::GetType()</a></code> function which returns different constants depending on the weight of the numeric value:<p>
<ul>
<li><b>wxJSONTYPE_SHORT:</b> the value is of type wxJSONVALUE_INT and it fits in a <b>short</b> <b>int</b> </li>
<li><b>wxJSONTYPE_USHORT:</b> the value is of type wxJSONVALUE_UINT and it fits in a <b>unsigned</b> <b>short</b> </li>
<li><b>wxJSONTYPE_LONG:</b> the value is of type wxJSONVALUE_INT and it fits in a <b>long</b> <b>int</b> but it is too large for <b>short</b> <b>int</b>. </li>
<li><b>wxJSONTYPE_ULONG:</b> the value is of type wxJSONVALUE_UINT and it fits in a <b>unsigned</b> <b>long</b> but it is too large for <b>unsigned</b> <b>short</b>. </li>
<li><b>wxJSONTYPE_INT64:</b> the value is of type wxJSONVALUE_INT and it is so large that it needs 64-bits. </li>
<li><b>wxJSONTYPE_UINT64:</b> the value is of type wxJSONVALUE_UINT and it is so large that it needs 64-bits.</li>
</ul>
The <b>GetType()</b> function relies on the definition of the SHORT_MAX, SHORT_MIN, USHORT_MAX, LONG_MAX, LONG_MIN, ULONG_MAX, macros to check if the value fits in a particular data type. If the macros are not defined (I do not know if this could happen), the wxJSON library defines them by itself according to the rules of the C99 standard (see the <code><a class="el" href="json__defs_8h.html">include/wx/json_defs.h</a></code> header file):<p>
<div class="fragment"><pre class="fragment">   C99 type      width (bits)         limits
   --------      ------------         ------
   <span class="keywordtype">short</span>            16                -32.768 .. +32.767
   ushort           16                0 .. 65.535
   <span class="keywordtype">long</span>             32                -2.147.483.648 .. +2.147.483.647
   ulong            32                0 .. +4.294.967.295
</pre></div><p>
Note that the C99 standard only defines the <em>minimum</em> width of these types; in addition, the C++ language does not define a minimum size for these integer types.<p>
Also note that the <a class="el" href="classwxJSONValue.html#464f3962a62fc31bd9b096ff7401495a" title="Return the type of the value stored in the object.">wxJSONValue::GetType()</a> function never returns wxJSONTYPE_INT. This is because the <b>int</b> data type has a variable bit-width that depends on the platform: on Win32 and GNU/Linux, the <b>int</b> type is the same as <b>long</b> (32 bits wide) but on other platforms it may be only 16 because the minimum width of <b>int</b> is 16 in the C99 standard. For this reason, it is always a good practice to never use <b>int</b> in C/C++ programming language but the <b>long</b> data type which ensures 32-bits integers.<p>
The <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class lets you use <b>int</b> as the returned data type because it defines the <b>Is(U)Int</b> memberfunction which returns the correct result depending on the definition of the INT_MAX, INT_MIN and UINT_MAX macros.<h2><a class="anchor" name="json_internals_array">
The array of values.</a></h2>
An object of this type holds an array of <code><a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a></code> objects. This means that you can have an array of integers, doubles, strings, arrays and key/value maps, too Moreover, the array can contain all these types. In other words, the first element can be an integer, the second element is another array, and the third one a key/value map.<p>
The type is implemented using a <b>wxObjArray</b> class which stores <code><a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a></code> objects. The declaration of this type follows the wxWidget's container classes declaration for arrays of objects:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">class </span><a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>;
  <a class="code" href="jsonval_8h.html#04aa53b4e1a610b524bc42b4ec5b58f4">WX_DECLARE_OBJARRAY</a>( <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>, <a class="code" href="jsonval_8h.html#50f303b311b8528404e9eadcf1c65e2f">wxJSONInternalArray</a> )
</pre></div><p>
Note that the name of the type contains the word <em>internal</em>. This means that the type is used internally by the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class and should not be used by the application. However, the class's API defines a member function that can be used to get the internal array type:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="jsonval_8h.html#50f303b311b8528404e9eadcf1c65e2f">wxJSONInternalArray</a>* <a class="code" href="classwxJSONValue.html#7f119169edbd8f0a2c7b552c53ba08f0" title="Return the stored value as an array object.">AsArray</a>() <span class="keyword">const</span>;
</pre></div><p>
which returns the pointer of the array, stored in the <code>wxJSONValue::m_value.m_valArray</code> data member. There is no need for the application to access the internal representation of the JSON array-type. Use the <a class="el" href="classwxJSONValue.html#f167cd46c230324f2571801bd231db19" title="Return the item at the specified index.">wxJSONValue::Item</a>, <a class="el" href="classwxJSONValue.html#7c3070f8cb80e599609461eb679ceec3" title="Return the item at the specified index.">wxJSONValue::ItemAt</a> and the subscript operator for retreiving array's values.<p>
If wxWidgest was built using the <code>--enable-stl</code> flag then this type is implemented as a STL <b>std::vector</b> type but the actual implementation used by wxWdigets is totally transparent for the user.<h2><a class="anchor" name="json_internals_map">
The map of key/value pairs.</a></h2>
An object of this type is a map of key / value pairs where the <b>key</b> is a string and the value is a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object: it can hold bools, integers, strings, arrays and key/value maps, too.<p>
This type is implemented using the <b>wxHashMap</b> class which is a simple, type-safe, and reasonably efficient hash map class whose interface is a subset of the interface of STL containers.<p>
The definition of the hashmap for <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> objects is as follows:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="jsonval_8h.html#1fd851e43a2081acc52cd8441e089f24">WX_DECLARE_STRING_HASH_MAP</a>( <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>, <a class="code" href="jsonval_8h.html#fd467c09a9467362fe6ede843fa5333a">wxJSONInternalMap</a> );
</pre></div><p>
Note that the name of the type contains the word <em>internal</em>. This means that the type is used internally by the wxJSONvalue class and should not be used by the application. However, the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> API defines a member function that can be used to get this object:<p>
<div class="fragment"><pre class="fragment">  <span class="keyword">const</span> <a class="code" href="jsonval_8h.html#fd467c09a9467362fe6ede843fa5333a">wxJSONInternalMap</a>* <a class="code" href="classwxJSONValue.html#f4740508a910a5ac96ca8c81a01037e2" title="Return the stored value as a map object.">AsMap</a>() <span class="keyword">const</span>;
</pre></div><p>
There is no need for the application to access the internal representation of the JSON hashmap-type. Use the <a class="el" href="classwxJSONValue.html#5fbd4722c4e93dc5de165932151e725e" title="Return the item at the specified key.">wxJSONValue::Item(const wxString&amp;)</a>, <a class="el" href="classwxJSONValue.html#7c3070f8cb80e599609461eb679ceec3" title="Return the item at the specified index.">wxJSONValue::ItemAt</a> and the subscript operator for retreiving hashmap's values.<p>
If wxWidgest was built using the <code>--enable-stl</code> flag then this type is implemented as a STL <b>std::vector</b> type but the actual implementation used by wxWdigets is totally transparent for the user.<h2><a class="anchor" name="json_internals_compare">
The comparison function and operator</a></h2>
You may have noticed that the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class does not define a comparison operator (the <b>operator==()</b> function). This is not a forgetfullness but a precise design choice because comparing wxJSON Value objects may be time-consuming and the meaning of <b>equal</b> is not applicable to JSON objects. Consider the following two JSON objects:<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// first object</span>
 {
   <span class="stringliteral">"font"</span> : {
     <span class="stringliteral">"size"</span> = 12,
     <span class="stringliteral">"face"</span> = <span class="stringliteral">"Arial"</span>,
     <span class="stringliteral">"bold"</span> = <span class="keyword">true</span>
   }
 }

 <span class="comment">// second object</span>
 {
   <span class="stringliteral">"font"</span> : {
     <span class="stringliteral">"face"</span> = <span class="stringliteral">"Arial"</span>,
     <span class="stringliteral">"bold"</span> = <span class="keyword">true</span>
     <span class="stringliteral">"size"</span> = 12,
   }
 }
</pre></div><p>
You have to note that the two objects are not <b>equal</b> because the order of the key/value pairs is not the same. Althrough, the values that the two objects contain are <b>the</b> <b>same</b>.<p>
For this reason the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class does not define the comparison operator but a similar function: the <code><a class="el" href="classwxJSONValue.html#4286140173839ebea59cb25746c85d15" title="The comparison function.">wxJSONValue::IsSameAs()</a></code> which returns TRUE if the two objects contain the same values even if they are not in the same order: this applies only for key/value maps but not for arrays because the latter are ordered collections of values.<p>
The comparison function is much time-consuming because it is recursive. All items are compared for <em>sameas</em> until the first couple of items returns FALSE.<p>
If the two objects are very complex, the comparison function is very slow and you are discouraged to use it unless it is strictly necessary. I have defined this function only for debugging purposes.<h3><a class="anchor" name="json_internals_compare_convert">
Comparing different types</a></h3>
A problem in the interpretation of <b>IsSameAs</b> arise when comparing different types that can be converted or promoted to another type. Consider the two following JSON values:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 100 );
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2( 100.0 );
  <span class="keywordtype">bool</span> r = v1.<a class="code" href="classwxJSONValue.html#4286140173839ebea59cb25746c85d15" title="The comparison function.">IsSameAs</a>( v2 );  <span class="comment">// should return TRUE</span>
</pre></div><p>
The above values will be stored as different types: the first as an integer and the second as a double but they are, in fact, <b>the</b> <b>same</b> value and the function should return TRUE. Until the release 0.2.1 included, the wxJSON library had a bug that cause the <code>IsSameAs()</code> function to return FALSE in the above example. This was due to the fact that the function first compared the types and if they differ, FALSE was immediatly returned without trying a type conversion.<p>
Starting from release 0.2.2, this bug was fixed and the <a class="el" href="classwxJSONValue.html#4286140173839ebea59cb25746c85d15" title="The comparison function.">wxJSONValue::IsSameAs()</a> function now correctly compares compatible types: by now, they only are the numeric types. In other words, a string that contains the same value as a numeric one is not the same. Example: <div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 100 );
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2( _T(<span class="stringliteral">"100"</span>));
  <span class="keywordtype">bool</span> r = v1.<a class="code" href="classwxJSONValue.html#4286140173839ebea59cb25746c85d15" title="The comparison function.">IsSameAs</a>( v2 );  <span class="comment">// returns FALSE</span>
</pre></div><p>
The comparison function takes care of the sign of integer types and correctly handles values that apear equal in memory but that express different values as for example:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// 'v1' and 'v2' have the same representation in memory (all bits</span>
  <span class="comment">// set) but the expressed values are totally different</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( -1 );            <span class="comment">// this is -1</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2( (<span class="keywordtype">unsigned</span>) -1);  <span class="comment">// this is 4.294.967.296</span>
  <span class="keywordtype">bool</span> r = v1.<a class="code" href="classwxJSONValue.html#4286140173839ebea59cb25746c85d15" title="The comparison function.">IsSameAs</a>( v2 );      <span class="comment">// returns FALSE</span>
</pre></div><h2><a class="anchor" name="json_comment">
C/C++ comments in JSON text</a></h2>
Starting with release 0.2, the wxJSON library recognizes and stores C/C++ comments in JSON value objects. See <a class="el" href="wxjson_comments.html">wxJSON internals: C/C++ comments storage</a> for a detailed implementation.<h2><a class="anchor" name="json_internals_reader">
The wxJSONReader class</a></h2>
<h2><a class="anchor" name="json_internals_writer">
The wxJSONWriter class</a></h2>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 7 22:40:56 2010 for wxJSON by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
