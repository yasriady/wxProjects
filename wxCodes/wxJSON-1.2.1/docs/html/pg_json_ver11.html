<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>wxJSON: wxJSON - The wxWidgets implementation of JSON</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="pg_json_ver11">Version 1.1 </a></h1><h2><a class="anchor" name="json_ver11_intro">
Introduction</a></h2>
Until version 1.0 the <b>wxJSON</b> reader and writer had some issues mostly related to speed. The problem was that both the reader and the writer processed every single character written to / read from streams or strings. Worst, for every character read from / written to a stream the wxJSON's implementation performed a character conversion from UTF-8 to <b>wchar_t</b> and viceversa. Also note that such a conversion is, for most characters, not needed at all because those chars are in the US-ASCII charset (0x00..0x7F). The speed issues only affected input and output from streams: if the JSON text has to be written to / read from <b>wxString</b> objects, no conversion is needed because the returned char is already in the correct encoding.<p>
In version 3.0 of the GUI framework, developers have introduced a radical change to Unicode support and the <b>wxString</b> class has totally changed in its internal organisation. In particular, the <b>wxString</b> class now stores strings in UTF-16 encoding on Windows and in UTF-8 on unix systems. The drawback is that on *nix systems the usual character access using subscripts such as:<p>
<div class="fragment"><pre class="fragment">        wxString s;
        s[n];
</pre></div><p>
is VERY inefficient because of the UTF-8 encoding. The conseguence is that in wxJSON there is a speed issue also when the JSON text input is from <b>wxString</b> and not only from streams.<h2><a class="anchor" name="json_ver11_goals">
What are the goals of the new 1.1 version</a></h2>
In order to find the best organization for the reader and the writer I have to first point out what are the goals of this new release of wxJSON:<p>
<ul>
<li>compatibility with wxWidgets 2.8 and 2.9</li>
</ul>
<ul>
<li>full compatibility with wxJSON version 1.0: I do not want to break the compatibility with 1.0 version otherwise I will have to change the major version number</li>
</ul>
<ul>
<li>speed improvements: I will try to speed-up both the reader and the writer. The conversion of <b>each</b> character is very slow; there are better solutions as pointed out by Piotr Likus in his e-mail of november 2008</li>
</ul>
<ul>
<li>simplicity: JSON format is very easy to read and write for humans but it is also easy for machines to parse and generate. The wxJSON library has to be simple in the processing of JSON text.</li>
</ul>
<h2><a class="anchor" name="json_ver11_solution">
The new wxJSON organisation</a></h2>
The <b>wxJSON</b> library allows you to write / read JSON text to / from two different types of objects:<p>
<ul>
<li>a string of type <code>wxString</code> </li>
<li>a stream of type <code>wxInput/OutputStream</code> </li>
</ul>
These two kinds of I/O classes are very different because of the internal representation of the JSON text: in particular, wxString uses UTF-16 on windows and UTF-32 on *nix systems up to <b>wxWidgets</b> <b>2.8</b>. UTF-8 is used on *nix systems in <code>wxWidgets</code> <code>2.9</code>. For streams the encoding is alwasy UTF-8. A further different encoding is used in ANSI mode: locale dependent one-byte characters.<p>
<dl class="user" compact><dt><b>Encoding formats in the different wxWidget's mode / versions</b></dt><dd></dd></dl>
<div align="center">
<img src="images/ver11.gif" alt="ver11.gif">
</div>
<p>
These encoding differences complicates very much the organization of the writer and the parser because character read from / written to JSON text has to be converted to a unique type for processing. Actually, each char is converted to a <b>wchar_t</b> type and it occurs in ANSI mode, too. This conversion slows down the processing very much. A further complication is that <b>wxWidgets</b> 2.9 does no more return a <b>char</b> or <b>wchar_t</b> type when accessing string objects but a helper class: <b>wxUniChar</b> which has its own encoding format so that it has to be further converted to <b>wchar_t</b>.<p>
The solution is to use only one encoding format for <b>all</b> types of I/O, build mode and wxWidget's versions: UTF-8 is the only one applicable to all these cases. Using UTF-8 as the unique I/O format has several advantages:<p>
<ul>
<li>converting a string to UTF-8 (for the reader) or a UTF-8 stream to a string (for the writer) is very easy and it does not take much time: furthermore, in wxWidgets 2.9 the wxString object uses UTF-8 as the internal encoding on some plaforms so the conversion costs nothing at all.</li>
</ul>
<ul>
<li>UTF-8 does not have endianness or byte order issues</li>
</ul>
<ul>
<li>the pocessing of characters is <em>byte-oriented</em> so there is no need to deal with <b>wchar_t</b> or <b>wxUniChar:</b> special JSON characters, literal and numbers lie in the US-ASCII character set (one UTF-8 byte).</li>
</ul>
<ul>
<li>the processing of strings is easy because when reading a string, the parser just store <b>all</b> UTF-8 bytes up to the closing double-quotes in a temporary buffer. When the string has been read, it is assigned to a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> of type <em>string</em> which contains a <b>wxString</b> object. The whole temporary buffer will be converted in a string using <code>wxString::FromUTF8</code>.</li>
</ul>
<ul>
<li>writing a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> to a UTF-8 stream is easy because all special JSON characters, literals and numbers are written as one-byte characters. Strings are written by converting the whole <b>wxString</b> in UTF-8 using <code>wxString::ToUTF8</code>.</li>
</ul>
<ul>
<li>from the point of view of the processing, there is no difference between ANSI and Unicode because the processing is byte-oriented.</li>
</ul>
Note that UTF-8 is already the normal encoding format for I/O on streams but what about <b>wxString</b> input and output? The answer is very simple: the parser will convert a <b>wxString</b> JSON text input in a UTF-8 temporary buffer and processed as a <b>wxMemoryInputStream</b>. On the other hand, the wxJSON writer will only write to a temporary <b>wxMemoryOutputStream</b> in UTF-8 format: the <b>wxString</b> JSON text output is retrieved by converting the temporary buffer to a string object.<h2><a class="anchor" name="json_ver11_ansiread">
Issues in ANSI mode</a></h2>
In version 1.0 the <b>wxJSON</b> library gives you a limited Unicode support in AMSI mode when reading UTF-8 streams. For example, suppose we have a UTF-8 file that contains the following data:<p>
<div class="fragment"><pre class="fragment">{
  <span class="stringliteral">"us-ascii"</span> : <span class="stringliteral">"abcABC"</span>,
  <span class="stringliteral">"latin1"</span>   : <span class="stringliteral">"‡ËÏ©Æ"</span>,
  <span class="stringliteral">"greek"</span>    : <span class="stringliteral">"aﬂ?d"</span>,
  <span class="stringliteral">"cyrillic"</span> : <span class="stringliteral">"????"</span>
}
</pre></div><p>
We read the file in a wxWidgets application built in ANSI mode and localized in West Europa thus using the ISO-8859-1 (Latin1) character set. Because Latin1 charset does not have support for greek and cyrillic characters, the reader <b>cannot</b> store such values in the <code><a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a></code> object because it contains a <code>wxString</code> object which only uses one-byte locale dependent characters to be stored.<p>
In order to keep the original meaning of data, the <b>wxJSON</b> library converted each character that cannot be represented in the current locale into a <em>unicode</em> <em>escaped</em> <em>sequence</em>. Below you find a representation of the content of the <code>wxJSONvalue</code> when the file is read:<p>
<div class="fragment"><pre class="fragment">{
  <span class="stringliteral">"us-ascii"</span> : <span class="stringliteral">"abcABC"</span>,
  <span class="stringliteral">"latin1"</span>   : <span class="stringliteral">"‡ËÏ©Æ"</span>,
  <span class="stringliteral">"greek"</span>    : <span class="stringliteral">"\u03B1\u03B2\u03B3\u03B4"</span>,
  <span class="stringliteral">"cyrillic"</span> : <span class="stringliteral">"\u0424\u0425\u0426\u0427"</span>
}
</pre></div><p>
I thought that this would be an elegant solution for reading UTF-8 streams in ANSI mode and that data could be exchanged safely from ANSI to Unicode and viceversa but... there are some drawbacks in this solution:<p>
<ul>
<li>because of the use of only four hexadecimal digits, only Unicode characters in the first plane (the so-called BMP) can be represented</li>
</ul>
<ul>
<li>writing the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> back to its JSON text representation does not revert to UTF-8 encoding: characters are written as <em>unicode</em> <em>escaped</em> <em>sequences</em> but I am not sure that this is valid JSON text altough wxJSON handles it correctly.</li>
</ul>
<ul>
<li>in order to get the <em>unicode</em> <em>escaped</em> <em>sequence</em> of unrepresentable chars, the <b>wxJSON</b> reader has to convert the string char-by-char which is what I want to avoid in this new version because such conversion slows drastically things down.</li>
</ul>
Because in the new organization the reader and the parser only process UTF-8 streams, there is a problem when the string contains unrepresentable UTF-8 characters. Note that this only happens in the parser class and when the JSON text input is actually from a stream: it does not happen if the processed stream is a temporary UTF-8 buffer obtained by converting the <b>wxString</b> input text.<p>
The solution suggested by Piotr Likus in his e-mail was pretty simple and very fast: who cares about internal encoding of <b>wxString</b>? When a double-quote character is encontered, just <b>copy</b> all the stream up to the next unescaped double-quote char; only process escaped sequences. The <b>wxString</b> object will, therefore, contain UTF-8 octets in ANY modes and platforms.<p>
Although this would be a very fast solution, one problem still remains: what if the stored strings have to be used / processed / displayed by the application? They surely need to be converted to the native internal encoding which is platform- and mode-dependant.<p>
So, I decided to do the conversion in the wxJSON reader and writer: string values are always stored in the native format so that they can be immediatly processed by the application: for speed purposes, the conversion is done for the whole string, in one step. But this is not applicable in the parser when ANSI mode is used. In the above example, the conversion of the greek and cyrillic strings simply fails and an empty string will be returned by the <code>wxString::FromUTF8</code> function.<p>
In order to keep the compatibility with the past, the wxJSON parser will still process UTF-8 streams in ANSI mode one character at a time but only if the conversion of the whole string fails. In this way, if the UTF-8 stream only contains characters that can be represented in the current locale (for example because the UTF-8 stream itself is only a temporary buffer, created by converting the <b>wxString</b> object used as input) no speed loss will occur.<p>
Furthermore, the user may specify a special symbol in the <code><a class="el" href="json__defs_8h.html">include/wx/json_defs.h</a></code> header file:<p>
<div class="fragment"><pre class="fragment">  wxJSON_ANSI_READUTF8
</pre></div><p>
which cause the wxJSON parser to store UTF-8 octets in the <b>wxString</b> object in ANSI mode, without trying any conversion. Note that the conversion is not tried at all, even if the UTF-8 stream is convertible in locale dependent characters. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Oct 22 18:15:09 2009 for wxJSON by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
