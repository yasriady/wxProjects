<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>wxJSON: wxJSON - The wxWidgets implementation of JSON</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="pg_json_ver11_12">July 2009: new features </a></h1><ul>
<li><a class="el" href="pg_json_ver11_12.html#json_ver11_12_intro">Introduction</a> </li>
<li><a class="el" href="pg_json_ver11_12.html#json_ver11_12_ver11">Version 1.1</a> </li>
<li><a class="el" href="pg_json_ver11_12.html#json_ver11_12_ver12">Version 1.2</a> </li>
<li><a class="el" href="pg_json_ver11_12.html#json_ver11_12_ver13">Version 1.3</a></li>
</ul>
<h2><a class="anchor" name="json_ver11_12_intro">
Introduction</a></h2>
Although the JSON format is very stable and the wxJSON library version 1.0 does implement all JSON specifications, I received some feature requests from wxJSON users so I am about to release a few new versions of the library. The first one is a workaround to correctly build the library on <code>MinGW</code> and the second one is an extension of the JSON syntax.<p>
In the third version I will not implement new features but some improvements related to speed. Compared to other JSON implementations, <code>wxJSON</code> is very slow in parsing JSON streams: some simple optimisations will surely speed it up.<h2><a class="anchor" name="json_ver11_12_ver11">
Version 1.1</a></h2>
As well known, the wxJSON library is a specialized JSON implementation for <code>wxWidgets</code> and it only depends on the <code>wxBase</code> library. No other external library is needed, in particular, wxJSON does not depend on <code>std::string</code> nor on STL containers.<p>
In order to store arrays and key/value pairs of objects the library uses the wxWidget's container implementation <code>wxObjArray</code> and <code>wxHashMap</code>. These implementations work fine on nearly all platforms but there are some systems that cannot compile the library if using wxWidget's container classes. One of these systems is <code>MinGW</code> which fails to compile the <code>wxHashMap</code> class due to the redefinition of the container (to know the details of this failure see the  <a href="http://sourceforge.net/tracker/?func=detail&aid=2807075&group_id=51305&atid=462816">http://sourceforge.net/tracker/?func=detail&amp;aid=2807075&amp;group_id=51305&amp;atid=462816</a> "wxCode bug trackign system bug ID 2807075").<p>
The solution for those systems is to actually use STL instead of wxWidget's containers. I tried this solution and it seems to work properly (thanks to Andrejs Cainikovs which actually tried the solution and wrote to me that it worked).<p>
Beside the compilation's problems, a wxWidget's application may also use STL for its own, so STL is available for both the application and wxWidgets. So why not use it for wxJSON, too.<p>
This release adds support for using STL containers for the array (<b>std::vector</b>) and object (<b>std::map</b>) JSON type intead of wxWidget's conainers. By default, this feature is disabled, you have to uncomment the line that contains:<p>
<div class="fragment"><pre class="fragment">  wxJSON_USE_STL
</pre></div><p>
in the the <code><a class="el" href="json__defs_8h.html">include/wx/json_defs.h</a></code> file.<h2><a class="anchor" name="json_ver11_12_ver12">
Version 1.2</a></h2>
All of you already know that JSON is a text-based data interchange format but the word <code>data</code> refers especially to <code>program</code> <code>variables</code> and not other kind of data. JSON is not suitable for exchanging binary data such as audio, video, image or complex documents and it should not because it was not developed for that purpose. The goals of JSON are: simple, human-readable, fasr and compact.<p>
On the other hand, there may be some particular situations in which a program should store and/or transmit small amount of binary data such as a small GIF image (for example a logo), a 1- or 2-seconds sound or a tiny memory buffer.<p>
In these situations, JSON is very limited: you cannot use JSON strings to store binary data because they are converted to UTF-8, the only possible solution is to use an array of numbers. For example, if we want to store a simple GIF image we can write something like the following:<p>
<div class="fragment"><pre class="fragment">  {
    <span class="stringliteral">"image"</span> :
    <span class="stringliteral">"type"</span>   : <span class="stringliteral">"gif"</span>,
    <span class="stringliteral">"width"</span>  : 160,
    <span class="stringliteral">"height"</span> : 160,
    <span class="stringliteral">"data"</span>   : [ 32, 160, 255, 47, 89, 47, 123, 85, ... ]
 }
</pre></div><p>
The above may be a solution but it consumes a lot of space because for every byte in the buffer we need 3-4 characters. Also, the program has to convert the buffer into an array of INTs when writing the JSON text and to convert it back when reading the stream.<p>
wxJSON introduces another JSON data type as an extension of the JSON syntax: the <em>binary</em> <em>buffer</em> type. In order to maintain the text-based format, the binary buffer is encoded as a string of two hexadecimal digits for every byte and it is enclosed in single quotes. The above example will look like the following:<p>
<div class="fragment"><pre class="fragment">  {
    <span class="stringliteral">"image"</span> :
    <span class="stringliteral">"type"</span>   : <span class="stringliteral">"gif"</span>,
    <span class="stringliteral">"width"</span>  : 160,
    <span class="stringliteral">"height"</span> : 160,
    <span class="stringliteral">"data"</span>   : <span class="stringliteral">'20A0FF2F592F7B55...'</span>
 }
</pre></div><p>
The reader will store such a type in a <code>wxMemoryBuffer</code> object and the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class will have functions to return it:<p>
<div class="fragment"><pre class="fragment">        <span class="keywordtype">bool</span>            wxJSONValue::IsMemBuffer();
        wxMemoryBuffer* wxJSONValue::AsMemBuffer();
</pre></div><p>
A value of that type can be stored in a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> by constructing the oject or by assigning to it a wxMemoryBuffer object or a void pointer.<p>
<div class="fragment"><pre class="fragment">        <a class="code" href="classwxJSONValue.html#b297ae154241e77c41f61af52d5d653f" title="Constructors.">wxJSONValue</a>( <span class="keyword">const</span> wxMemoryBuffer&amp; mem );
        <a class="code" href="classwxJSONValue.html#b297ae154241e77c41f61af52d5d653f" title="Constructors.">wxJSONValue</a>( <span class="keyword">const</span> <span class="keywordtype">void</span>* mem, <span class="keywordtype">size_t</span> size );
</pre></div><p>
As the <em>memory</em> <em>buffer</em> is not valid JSON text, you have to use a special wxJSONReader's flag in order to handle it otherwise an error will be reported.<p>
By default, the <a class="el" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> will write a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> that contains a <em>binary</em> <em>buffer</em> type as an array of INTs thus producing valid JSON text output. If you want to write the special <em>binary</em> <em>buffer</em> type which will be recognized by the reader, you have to use a special writer's flag when constructing it. Note that other JSON implementations will fail to read such a text.<h2><a class="anchor" name="json_ver11_12_ver13">
Version 1.3</a></h2>
Compared to other JSON implementations, wxJSON is very slow when it reads UTF-8 streams. I ran some speed tests (see <code>samples/test15.cpp</code>) for reading from / writing to wxString and streams in both ANSI and Unicode builds. The JSON value to be read / written is an array of 10,000 elements each of which contains 4 key/value pairs.<p>
If the JSON text has to be read from / written to a wxstring object, the test application took 1.4 and 1.6 seconds in ANSI and Unicode mode, respectively (not really a lot of time, I think). ANSI seems to be faster than Unicode: probably this is because <code>wxString</code> objects stores strings in one-byte characters.<p>
Using streams, the write process took 2.4 seconds in ANSI builds and 1.9 seconds in Unicode. Now Unicode seems faster, I think because in ANSI builds characters go through a double conversion:<p>
<ul>
<li>1. from locale dependent charset to Unicode </li>
<li>2. from Unicode to UTF-8</li>
</ul>
In Unicode builds only the second conversion takes place so Unicode is faster than ANSI.<p>
In order to speed things up when using UTF-8 streams, there are several optimisations that could be used in the wxJSON writer:<p>
<ul>
<li>because special JSON characters, numbers and JSON literals are in the US-ASCII character set (0x00..0x7F) the UTF-8 encoding of such characters is the same as the US-ASCII: no conversion is needed at all.</li>
</ul>
<ul>
<li>conversion from Unicode to UTF-8 is only needed for string values: it is more convenient to convert the whole string instead of character by character</li>
</ul>
<ul>
<li>conversion from ANSI to UTF-8 is only needed for string values and should be performed using the <code>wxstring::utf8_str()</code> function which does the conversion in only one step.</li>
</ul>
For speeding-up the wxJSON parser, the following tricks can be used:<p>
<ul>
<li>when reading a UTF-8 character which is composed of only one byte (codes from 0x00 to 0x7F) no conversion is needed in both ANSI and Unicode builds</li>
</ul>
<ul>
<li>conversion is only needed when reading a string value or a C/C++ comment: it is more convenient to store the string or the comment in a temporary buffer and to perform the conversion on the whole string: this is only applicable to Unicode builds</li>
</ul>
In ANSI, when reading a string or a comment, the parser checks that a character is convertible to the locale dependent charset. If not the <em>unicode</em> <em>escaped</em> <em>sequence</em> is stored in the ANSI string. So the conversion has to be performed char-by-char in ANSI and I think that there is not a trick for not doing so.<p>
<dl class="user" compact><dt><b>json_ver11_12_ver13_std Use of std::string and wxJSON</b></dt><dd></dd></dl>
Another issue related to speed when reading from / writing to UTF-8 streams is that some <b>wxJSON</b> users actually use the library for JSON data but they use the <code>std::string</code> class for storing strings and not the <b>wxString</b> class. I do not know why they do so but the problem in using wxJSON is that on some platforms (maybe Windows?) the <code>std::string</code> class stores strings internally in UTF-8 format.<p>
As a conseguence, when they want to write to UTF-8 streams they have to convert strings to <code>wxString</code> (which uses UCS-2 or UCS-4 encoding) and then back to UTF-8: clearly, this unnecessary double conversion slows things down.<p>
I am very sorry for this issue but <b>wxJSON</b> was written to let JSON data be easily accessible from <b>wxWidgets</b>. For those users my only tip is to use other JSON implementations which natively use <code>std::string</code> for storing strings. For example they can take a look at  <a href="http://sourceforge.net/projects/jsoncpp/">http://sourceforge.net/projects/jsoncpp/</a> "jsoncpp" from which the wxJSON's interface heavily derives. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Oct 22 18:15:09 2009 for wxJSON by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
