<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>wxJSON: wxJSON - The wxWidgets implementation of JSON</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="wxjson_comments">wxJSON internals: C/C++ comments storage </a></h1><h2><a class="anchor" name="main_intro">
Introduction</a></h2>
Starting from release 0.2, the wxJSON library recognizes and stores C/C++ comments in JSON value objects. Comments are stored in a wxJSONValue's data member which is of type <code>wxArrayString</code>.<p>
An array is used because a value may have more than one comment line. When a JSON value object is created, the comment's array is empty.<p>
There are two methods for adding comment lines to a JSONvalue object:<p>
<ul>
<li>using member functions </li>
<li>reading them from a JSON text</li>
</ul>
<h2><a class="anchor" name="json_comment_add">
Adding C/C++ comments using member functions</a></h2>
The <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object defines some member function in order to add C/C++ comments to a value object. The value object contains an array of string for storing comments and an enumerator for setting the position of the comment line(s):<p>
<ul>
<li>comments may be written <b>inline</b> </li>
<li>comments may be written <b>before</b> the value </li>
<li>comments may be written <b>after</b> the value</li>
</ul>
Note that the position of the comment is not an array of enums but it only is a simple integer data member. This means that the position of the comment is set for all comment's strings; all comments may apear inline, before or after the value they refer to and you cannot have mixed positioned comments.<p>
You can add C-style comments and / or C++ comments. When you add a comment string you have to be sure that the string is a correct C/C++ comment. In other words, if you want to add a C++ comment string, the string passed as a parameter to the <a class="el" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">wxJSONValue::AddComment()</a> function must start with two slash characters and must end with a LF. If the LF character is missing, the function adds it for you. The following code fragment shows some examples:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 10 );
  v1.AddComment( <span class="stringliteral">"// A C++ comment line\n"</span> );     <span class="comment">// this is OK</span>
  v1.AddComment( <span class="stringliteral">"// Another C++ comment line"</span> ); <span class="comment">// this is OK</span>
  v1.AddComment( <span class="stringliteral">"/*  A C-style comment */"</span>);     <span class="comment">// OK</span>

  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2( 20 );
  v2.AddComment( <span class="stringliteral">"A C++ comment line\n"</span> );     <span class="comment">// Error</span>
  v2.AddComment( <span class="stringliteral">"/ A C++ comment line\n"</span> );   <span class="comment">// Error</span>
  v2.AddComment( <span class="stringliteral">"/*** comment **"</span> );          <span class="comment">// Error</span>

  <span class="comment">// the following is OK: new-line characters may follow</span>
  <span class="comment">// the end-comment characters of a C-style comment</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v3( 30 );
  v2.AddComment( <span class="stringliteral">"/*** C comment ***/\n\n\n"</span> );
</pre></div><p>
Note that the function cannot trap all possible errors because the checks that are done by the function are very simple:<p>
<ul>
<li>for C++ comments checks that the string starts with two slash characters and ends with a LF char: the LF har is automatically added if it is missing </li>
<li>for C-style comments check that the string start with the slash-asterisk character couple and ends with the asterisk-slash caracters (trailing LF chars are permitted)</li>
</ul>
Note that the following examples are considered OK by the function but if you add those strings to some values and write them to a JSON text stream you end up with a incorrect JSON text.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// the following is not correct: the AddComment() function only</span>
  <span class="comment">// appends the final LF char </span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 10 );
  v1.AddComment( <span class="stringliteral">"// Line 1\nLine2"</span> );
</pre></div><p>
Writing the above value you get:<p>
<div class="fragment"><pre class="fragment">  ...
  <span class="comment">// Line 1</span>
  Line 2
  10
  ...
</pre></div><p>
You would have to write:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 10 );
  v1.AddComment( <span class="stringliteral">"// Line 1"</span> );
  v1.AddComment( <span class="stringliteral">"// Line 2"</span> );
</pre></div><p>
Nested C-style comments are not handled by the wxJSON parser:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2( 20 );
  v2.AddComment( <span class="stringliteral">"/* comment1 /* comment2 */ */"</span> );
</pre></div><p>
Writing the above value to a JSON text string you get:<p>
<div class="fragment"><pre class="fragment">  ...
  <span class="comment">/* comment1 /* comment2 */</span> */
  20
  ...
</pre></div><p>
The parser will report an error when it reads the last close-comment characters because when a C-style comment starts, all characters until the first close-comment chars are ignored by the parser.<h2><a class="anchor" name="json_comment_inline">
Using multiple inline comments</a></h2>
Comments may apear inline, after or before the value they refer to. When using the wxJSONValue::AddComent() function you can mix these positions for different values as, for example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> root;
  root[<span class="stringliteral">"key-1"</span>] = <span class="stringliteral">"value-1"</span>;
  root[<span class="stringliteral">"key-2"</span>] = <span class="stringliteral">"value-2"</span>;
  root[<span class="stringliteral">"key-3"</span>] = <span class="stringliteral">"value-3"</span>;

  root[<span class="stringliteral">"key-1"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment before"</span>, <a class="code" href="jsonval_8h.html#df764cbdea00d65edcd07bb9953ad2b740fcad8684e55757572c512883fe4a03">wxJSONVALUE_COMMENT_BEFORE</a> );
  root[<span class="stringliteral">"key-2"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment inline"</span>, <a class="code" href="jsonval_8h.html#df764cbdea00d65edcd07bb9953ad2b72ec7d0fa07e8bf91263abe3e3dd75583">wxJSONVALUE_COMMENT_INLINE</a> );
  root[<span class="stringliteral">"key-3"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment after"</span>, <a class="code" href="jsonval_8h.html#df764cbdea00d65edcd07bb9953ad2b738f9c851a81c2ffa53b547f65b7d7b40">wxJSONVALUE_COMMENT_AFTER</a> );
</pre></div><p>
When you write the above JSON value you get:<p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// comment before</span>
  <span class="stringliteral">"key-1"</span> : <span class="stringliteral">"value-1"</span>,
  <span class="stringliteral">"key-2"</span> : <span class="stringliteral">"value-2"</span>, <span class="comment">// comment inline</span>
  <span class="stringliteral">"key-3"</span> : <span class="stringliteral">"value-3"</span>
  <span class="comment">// comment after</span>
}
</pre></div><p>
This is not really good: you have to choose a position between comments before and comments after. Inline comments may apear in both cases. Note that comments inline are only indented for the first line of comments. if you add more than one line of comment in inline position, the first line is written on the same line as the value it refers to and the other comment's lines are written after the value. Example:<p>
<div class="fragment"><pre class="fragment">  <span class="stringliteral">"key-2"</span> : <span class="stringliteral">"value-2"</span>, <span class="comment">// comment inline (line 1)</span>
<span class="comment">// comment inline (line 2)</span>
<span class="comment">// comment inline (line 3)</span>
  <span class="stringliteral">"key-3"</span> : <span class="stringliteral">"value-3"</span>
</pre></div><p>
The output is not very good so use inline comments only for very short comment's strings.<h2><a class="anchor" name="json_comment_read">
Reading and storing C/C++ comments from JSON text</a></h2>
Comment lines are stored when they are encontered in the JSON input text stream. The parser stores comments in the value they refer to. In order to know to which value a comment line refers, the following rules are followed:<p>
<ul>
<li>if the comment line and the value apear on the same line the comment line refers to that value </li>
<li>if the flag wxJSONREADR_COMMENTS_AFTER is not set, a comment line refers to the value that follows the comment line(s) </li>
<li>if the flag wxJSONREADR_COMMENTS_AFTER is set, a comment line refers to the value that apears immediatly before the comment line(s)</li>
</ul>
Below you find some examples:<p>
<div class="fragment"><pre class="fragment"><span class="comment">// comment for root (line 1)</span>
<span class="comment">// comment for root (line 2)</span>
{
  <span class="stringliteral">"key-1"</span> : <span class="stringliteral">"value1"</span>,

  <span class="comment">// comment before 'key2'</span>
  <span class="stringliteral">"key-2"</span> : <span class="stringliteral">"value2"</span>,

  <span class="stringliteral">"key-3"</span> : {
     <span class="stringliteral">"key3-1"</span> : <span class="stringliteral">"value3-1"</span>,
     <span class="stringliteral">"key3-2"</span> : <span class="stringliteral">"value3-2"</span>   <span class="comment">// comment inline for 'key3-2'</span>
  },

  <span class="stringliteral">"key-4"</span> : {   <span class="comment">// comment inline for 'key4'</span>
  },

  <span class="stringliteral">"key-5"</span> : <span class="stringliteral">"value-5"</span>
  <span class="comment">// if the flag wxJSONREADER_COMMENT_AFTER is set, this</span>
  <span class="comment">// comment would refer to 'key-5'</span>
}
</pre></div><p>
The parser will store the comment in the value it refers to and in the same position it was encontered: if a comment is on the same line as the value, the comment will be stored as an <b>inline</b> comment: when the value will be written to a JSON text stream, the comment will be written in the same position unless you specify a flag that forces the writer to write comments in a particular position.<h3><a class="anchor" name="wxjson_comments_rules">
Choosing the value</a></h3>
How does the parser choose the correct value to store the comment?<p>
The parser uses some data members to store pointers to values:<p>
<ul>
<li><code>m_next:</code> this pointer holds the value object that will hold the <b>next</b> value that has to be read. When the comments apear <b>before</b> the value, the comment is added to this value, unless it is NULL. In the ezample above, when the first two comment lines are read, this pointer points to the root value object.</li>
</ul>
<ul>
<li><code>m_current:</code> this pointer points to the value object that the parser is reading at the moment. It can be NULL if the parser has not yet read a value. In the ezample above, when the first two comment lines are read, this pointer is NULL. When the first <em>open-object</em> char is read, this pointer points to the root value.</li>
</ul>
<ul>
<li><code>m_lastStored:</code> this pointer points to the value that was last stored in an object or in an array. Comments are added to the value pointed to by this data member when the wxJSONREADER_COMMENTS_AFTER is set.</li>
</ul>
In addition, the parser stores the line number of every comment line that was read and also the line number of the value when it is read: if the line numbers match, the comment is added to the matching value as an <b>inline</b> comment.<h3><a class="anchor" name="wxjson_comments_example2">
A complex example</a></h3>
Below you find a more complex example and the explanation of every operation done by the parser when the comment lines are encontered. The numbers on the first two columns refers to the line numbers of the JSON text input stream. The comment flag is BEFORE:<p>
<div class="fragment"><pre class="fragment"> 1 <span class="comment">// comment for root (line 1)</span>
 2 <span class="comment">// comment for root (line 2)</span>
 3 {
 4   <span class="stringliteral">"key-1"</span> : <span class="stringliteral">"value1"</span>,
 5
 6   <span class="comment">// comment before 'key2'</span>
 7   <span class="stringliteral">"key-2"</span> : <span class="stringliteral">"value2"</span>,
 8   <span class="comment">// comment before 'key3' (1)</span>
 9   <span class="comment">// comment before 'key3' (2)</span>
10
11   <span class="stringliteral">"key-3"</span> : {
12      <span class="stringliteral">"key3-1"</span> : <span class="stringliteral">"value3-1"</span>,
13
14      <span class="comment">// comment before key3-2</span>
15      <span class="stringliteral">"key3-2"</span> : <span class="stringliteral">"value3-2"</span>
16   },
17
18   <span class="stringliteral">"key-4"</span> : {   <span class="comment">// comment inline key4</span>
19      <span class="comment">// this comment does not refer to anything (19)</span>
20   }
21
22   <span class="stringliteral">"key-5"</span> : [ <span class="comment">// comment inline key5</span>
23
24      <span class="comment">// comment before item 5-1</span>
25      <span class="stringliteral">"item5-1"</span>,
26      <span class="stringliteral">"item5-2"</span>, <span class="comment">// comment inline 5-2</span>
27      <span class="stringliteral">"item5-3"</span>  <span class="comment">// comment inline 5-3</span>
28
29      <span class="comment">// this comment does not refer to anything (29)</span>
30   ],
31
32   <span class="stringliteral">"key-6"</span>
33      :        <span class="comment">// comment inline key-6</span>
34        <span class="stringliteral">"value"</span>,
35
36   <span class="stringliteral">"key-7"</span> : {
37      <span class="stringliteral">"key-7-1"</span> : <span class="stringliteral">"value-7-1"</span>
38   },        <span class="comment">// comment inline key-7</span>
39
40   <span class="stringliteral">"key-8"</span>     <span class="comment">// comment inline key-8(1)</span>
41      :        <span class="comment">// comment inline key-8(2)</span>
42       value,  <span class="comment">// comment inline key-8(3)  // ERROR: string-value not quoted</span>
43
44   <span class="stringliteral">"key-8"</span>     <span class="comment">// comment inline key-8(1)</span>
45      :        <span class="comment">// comment inline key-8(2)</span>
46      <span class="stringliteral">"value"</span>, <span class="comment">// comment inline key-8(3)</span>
47
48   <span class="stringliteral">"key-9"</span> : {
49      <span class="stringliteral">"key9-1"</span> : 91,
50      <span class="stringliteral">"key9-2"</span> : 92
51   }
52
53
54   <span class="stringliteral">"key-10"</span> : [
55   ]            <span class="comment">// comment inline key-10</span>
56
57   <span class="comment">// this comment does not refer to anything (57)</span>
58 }
59 <span class="comment">// this comment does not refer to anything</span>
60 <span class="comment">// if COMMENT_BEFORE.</span>
61
62 This non-JSON text is ignored by the parser because
63 it apears after the top-level close-<span class="keywordtype">object</span> character
64
</pre></div><h3><a class="anchor" name="wxjson_comments_details">
The detailed explanation of the example</a></h3>
<div class="fragment"><pre class="fragment"> 1 <span class="comment">// comment for root (1)</span>
 2 <span class="comment">// comment for root (2)</span>
 3 {

  m_current    = NULL
  m_next       = the <span class="stringliteral">'root'</span> value
  m_lastStored = NULL
</pre></div><p>
The first comment is read in the GetStart() function which searches for the first '{' (open-object) or '[' (open-array) characters. When the two comment lines are read, the pointers contains the following values:<p>
Because the flag is COMMENT_BEFORE the comment is added to the value pointed to by <code>m_next</code>.<p>
<div class="fragment"><pre class="fragment"> 3 {
 4   <span class="stringliteral">"key-1"</span> : <span class="stringliteral">"value1"</span>,
 5
 6   <span class="comment">// comment before 'key2'</span>
 7   <span class="stringliteral">"key-2"</span> : <span class="stringliteral">"value2"</span>,

  m_current    = NULL
  m_next       = the temporary \c value which will contain <span class="stringliteral">'key-2'</span>
  m_lastStored = key-1
</pre></div><p>
This example is similar to the above. The top-level <em>start-object</em> character causes the parser to enter the <code>DoRead()</code> function which has the <b>root</b> value object as the <em>parent</em> parameter. Every value is stored in a temporary <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object created on the stack which is kept in the variable <code>value</code>. The parser stores the value when the comma character is encontered or when the close-object char is encontered.<p>
The comment line is added to the value pointed to by <code>m_next</code>.<p>
<div class="fragment"><pre class="fragment"> 8   <span class="comment">// comment before 'key3' (1)</span>
 9   <span class="comment">// comment before 'key3' (2)</span>
10
11   <span class="stringliteral">"key-3"</span> : {

  m_current    = NULL
  m_next       = the temporary \c value which will contain <span class="stringliteral">'key-3'</span>
  m_lastStored = key-2
</pre></div><p>
This is the same as above. The only difference is that there are two comment lines but they are all added to the value pointed to by <code>m_next</code>. You can add as many lines as you want.<p>
<div class="fragment"><pre class="fragment">11   <span class="stringliteral">"key-3"</span> : {
12      <span class="stringliteral">"key3-1"</span> : <span class="stringliteral">"value3-1"</span>,
13
14      <span class="comment">// comment before key3-2</span>
15      <span class="stringliteral">"key3-2"</span> : <span class="stringliteral">"value3-2"</span>
16   },

  m_current    = NULL
  m_next       = the <span class="stringliteral">'value'</span> which will contain <span class="stringliteral">'key3-2'</span>
  m_lastStored = key3-1
\endcoe


This is very similar to the above cases. 

\code
17
18   <span class="stringliteral">"key-4"</span> : {   <span class="comment">// comment inline key4</span>
19      <span class="comment">// this comment does not refer to anything</span>
20   }
21

   m_current    = key-4 (the parent)
   m_next       = temporary \c value <span class="keywordtype">object</span>
   m_lastStored = NULL
</pre></div><p>
When the two comments are read, the value of the pointer data members is the same for both comments but they are stored in a different value object. When the <em>open-object</em> character is read on line 18, the parser sets the <code>m_current</code> data member equal to the temporary <code>value</code> object on the stack which is the 'parent' of all values read until the <em>close-object</em> character. Then, the DoRead() function is called recursively, which allocates another temporary <code>value</code> object on the stack.<p>
We have to examine the two comment lines differently:<p>
<ul>
<li>the comment on line 18 is on the same line as the value pointed to by <code>m_current</code> so it will be added to that value as an <b>inline</b> comment.</li>
</ul>
<ul>
<li>the comment on line 19 cannot be added as an <b>inline</b> comment, so, because the comment flag is BEFORE, it is added to the value object pointed to by <code>m_next:</code> this comment would refer to the first value that has <b>key-4</b> as the parent.</li>
</ul>
Because <b>key-4</b> is empty, no value is added to it and the temporary <code>value</code> object created on the stack by the DoRead() function will be destroyed when the DoRead() function returns: the <em>close-object</em> character on line 20 causes the function to return. The comment line on line 19, stored in the temporary <code>value</code> object is lost, because thar object was not added to the parent,<p>
<div class="fragment"><pre class="fragment">25      <span class="stringliteral">"item5-1"</span>,
26      <span class="stringliteral">"item5-2"</span>, <span class="comment">// comment inline 5-2</span>

  m_current    = NULL 
  m_next       = temporary <span class="stringliteral">'value'</span> which will <span class="keyword">get</span> <span class="stringliteral">'item5-3'</span> <span class="keywordtype">string</span>
  m_lastStored = <span class="stringliteral">'item5-2'</span>
</pre></div><p>
When the parser reads the comma character on line 26, it stores the temporary value object in the parent value object and sets the <code>m_lastStored</code> data member pointing this last stored value. The <code>m_next</code> pointer points to the temporary value object on the stack and it will get the <b>item5-3</b> string value. The parser checks the line number of the comment line and searches a matching line value in the value objects pointed to by all the three pointers, provided that they are not NULL. A matching line number value is found in the value pointed to by <code>m_lastStored</code> so the comment is added to that value as an <b>inline</b> comment.<p>
<div class="fragment"><pre class="fragment">27      <span class="stringliteral">"item5-3"</span>  <span class="comment">// comment inline 5-3</span>
28
29      <span class="comment">// this comment does not refer to anything</span>
30   ],

  m_current    = temporary <span class="stringliteral">'value'</span> which contains <span class="stringliteral">'item5-3'</span> <span class="keywordtype">string</span> 
  m_next       = NULL
  m_lastStored = <span class="stringliteral">'item5-2'</span>
</pre></div><p>
The value that holds the <b>item5-3</b> string is not yet stored when the parser reads the comment on line 27. This is because the temporary value created on the stack is stored when the comma character is encontered or when the <em>close-array</em> character is encontered. The comment will be added to value pointed to by <code>m_current</code> because the line numbers are equal.<p>
The comment on line 29 is lost because it is added to the temporary <code>value</code> object which is not stored. See the same situation on line 19.<p>
<div class="fragment"><pre class="fragment">31
32   <span class="stringliteral">"key-6"</span>
33      :        <span class="comment">// comment inline key-6</span>
34        <span class="stringliteral">"value"</span>,
35

  m_current    = <span class="stringliteral">'value'</span> which contains <span class="stringliteral">'key-6'</span>
  m_next       = NULL
  m_lastStored = <span class="stringliteral">'key-5'</span>
</pre></div><p>
The comment is added to the value pointed to <code>m_current</code> because the line numbers are equal. The parser updates the line number of a value each time it reads a character that belongs to a value: the semicolon character is one of these characters. Note that the comma is also a character that belongs to a value.<p>
<div class="fragment"><pre class="fragment">35
36   <span class="stringliteral">"key-7"</span> : {
37      <span class="stringliteral">"key-7-1"</span> : <span class="stringliteral">"value-7-1"</span>
38   },        <span class="comment">// comment inline key-7</span>

  m_current    = NULL
  m_next       = <span class="stringliteral">'value'</span> which will contain <span class="stringliteral">'key-8'</span>
  m_lastStored = <span class="stringliteral">'key-7'</span>
</pre></div><p>
The comma character on line 30 causes the parser to store the value <b>key-7</b> in the parent object (the root object). The comment is added to the value pointed to by <code>m_lastStored</code> because the line numbers are equal. The comment's position is <b>inline</b>.<p>
<div class="fragment"><pre class="fragment">39
40   <span class="stringliteral">"key-8"</span>     <span class="comment">// comment inline key-8(1)</span>
41      :        <span class="comment">// comment inline key-8(2)</span>
42       value,  <span class="comment">// comment inline key-8(3)     // ERROR: value not quoted</span>
43

Line 40 and 41
  m_current    = the temporary <span class="stringliteral">'value'</span> <span class="keywordtype">object</span>
  m_next       = NULL
  m_lastStored = NULL

Line 42
  m_current    = NULL
  m_next       = the temporary <span class="stringliteral">'value'</span> <span class="keywordtype">object</span>
  m_lastStored = NULL
</pre></div><p>
This is a very particular situation that cause the parser to behave incorrectly. Note that the incorrect behaviour is a conseguence of a syntax error so it cannot be considered a bug.<p>
The two comments on lines 40 and 41 are added to the value object pointed to by <code>m_current</code> and this is OK. When the value will be stored (if it could be) the comments refers to the corrent value as <b>inline</b> comments.<p>
The parser reads the <b>value</b> string but reports an error: a string must be quoted. As a conseguence, the temporary value object has a key but it does not have a value. Next, the parser reads the comma character and calls the StoreValue() function which will add the temporary value object to the parent object. But the value cannot be added to the parent because it does not have a valid value. The conseguence is that the <code>m_lastStored</code> pointer is set to NULL because no value was actually stored. If the value would be stored, the comment line on line 42 will be correctly added to the value pointed to by <code>m_lastStored</code> because the line numbers are equal.<p>
But when the parser reads the comment on line 42, the content of the <code>m_lastStored</code> pointer is NULL so the comment is added to the value pointed to by <code>m_next</code> because the comment flag is BEFORE. The incorrent behaviour is that the value of key <b>key-8</b> (see below) will have four comment lines and not three as we expect.<p>
----- <div class="fragment"><pre class="fragment">43
44   <span class="stringliteral">"key-8"</span>     <span class="comment">// comment inline key-8(1-1)</span>
45      :        <span class="comment">// comment inline key-8(1-2)</span>
46      <span class="stringliteral">"value"</span>, <span class="comment">// comment inline key-8(1-3)</span>
47

  m_current    = NULL
  m_next       = <span class="stringliteral">'value'</span> which is empty
  m_lastStored = key-8
</pre></div><p>
See the description of the above item. The difference is that this value is correctly added to the parent. As not expected, it has four comment lines instead of three.<p>
<div class="fragment"><pre class="fragment">53
54   <span class="stringliteral">"key-10"</span> : [
55   ]            <span class="comment">// comment inline key-10</span>
56

  m_current    = temporary <span class="stringliteral">'value'</span> <span class="keywordtype">object</span>
  m_next       = NULL
  m_lastStored = NULL
</pre></div><p>
The comment is added to the value pointed to by <code>m_current</code> because the line numbers match. For an <em>object-type</em> value, the line number is updated when the parser reads the open- and -close object character.<p>
<div class="fragment"><pre class="fragment">56
57   <span class="comment">// this comment does not refer to anything</span>
58 }

  m_current    = the temporary <span class="stringliteral">'value'</span> <span class="keywordtype">object</span> which contains <span class="stringliteral">'key-10'</span>
  m_next       = NULL
  m_lastStored = <span class="stringliteral">'key-9'</span>
</pre></div><p>
The comment is lost because if should be stored in the value object pointed to by <code>m_next</code> but this pointer is NULL so the comment cannot be stored.<p>
<div class="fragment"><pre class="fragment">58 }
59 <span class="comment">// this comment is not stored in the root value</span>
60 <span class="comment">// if COMMENT_BEFORE. If should be if COMMENT_AFTER.</span>
61
62 This non-JSON text is ignored by the parser because
63 it apears after the top-level close-<span class="keywordtype">object</span> character
64

  m_current    = NULL
  m_next       = NULL
  m_lastStored = the root value
</pre></div><p>
Because the <a class="el" href="classwxJSONReader.html#0489ac2d5b7485d7fd84d83a7eac4929" title="Reads the JSON text document (internal use).">wxJSONReader::DoRead()</a> function returned in line 58, all text after the top-level <em>close-object</em> or <em>close-array</em> character is ignored by the parser. For COMMENTS_BEFORE this is OK but if the flag was COMMENT_AFTER, the two comments on line 59 and 60 should be stored in the root value: but this does not happen, by now. This is not a bug but a precise desing choice;when the top-level <a class="el" href="classwxJSONReader.html#0489ac2d5b7485d7fd84d83a7eac4929" title="Reads the JSON text document (internal use).">wxJSONReader::DoRead()</a> function returns, the parsing process ends.<p>
So, if you want to store comments for the root value, never use the wxJSONREADER_COMMENTS_AFTER flag and put comments before the top-level <em>start-object</em> or <em>start-array</em> character. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 7 22:40:55 2010 for wxJSON by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
