<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>wxJSON: wxJSON - The wxWidgets implementation of JSON</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="wxjson_tutorial">wxJSON - A brief tutorial </a></h1>This page is a simple tutorial that describes how to use the wxJSON library in order to store data in JSON format, reading them, changing the values and how to generate JSON text that can be saved to a file, a stream or sent over a network connection.<h2><a class="anchor" name="wxjson_tutorial_toc">
Table of contents</a></h2>
<ul>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_intro">Introduction</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_ex1">Example 1: a simple example</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_ex2">Example 2: a configuration file</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_ex3">Example 3: Describing a table</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_get">Obtaining values from JSON value class</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_read_numbers">How numbers are read from JSON text.</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_write_doubles">Writing doubles to JSON text output</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_memorybuff">Storing binary memory buffers</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_comment">Using comment lines in wxJSON</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_unicode">Unicode support in wxJSON</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_style">The wxJSON writer's styles</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_error">Error reporting in the parser</a> </li>
<li><a class="el" href="wxjson_tutorial.html#wxjson_tutorial_stdstr">wxJSON and the std::string</a></li>
</ul>
<h2><a class="anchor" name="wxjson_tutorial_intro">
Introduction</a></h2>
JSON is a text format and it is completely platform-independent. You do not need to worry about computer's architecture, endianness or operating system. It is very easy for humans to read and write and easy for machines to parse and generate. It is also light-weight and much more compact than any other text-based data-interchange formats.<p>
We will learn how to use the wxJSON library by examining some simple examples. JSON is a data format; it is not suitable for describing complex documents or to store images, audio and video streams. For these purposes, there are many other formats which are by far more appropriate than JSON.<p>
If you are new to JSON, it is better that you first read the following page, which describe the JSON syntax, its advantages and its disadvantages:<p>
<ul>
<li><a href="http://www.json.org">Introducing JSON</a></li>
</ul>
<h2><a class="anchor" name="wxjson_tutorial_ex1">
Example 1: a simple example</a></h2>
Let's look an example on how to read and write JSON data using the wxWidgets implementation of the JSON value class. Suppose we have the following text stored in a wxString object (but you can also read it from a stream class):<p>
<div class="fragment"><pre class="fragment"> <span class="comment">/***************************</span>
<span class="comment">  This is a C-style comment</span>
<span class="comment"> ***************************/</span>
 {
   <span class="comment">// this is a comment line in C++ style</span>
   <span class="stringliteral">"wxWidgets"</span> :
   {
     <span class="stringliteral">"Description"</span> : <span class="stringliteral">"Cross-platform GUI framework"</span>,
     <span class="stringliteral">"License"</span> : <span class="stringliteral">"wxWidgets"</span>,
     <span class="stringliteral">"Version"</span> :
     {
       <span class="stringliteral">"Major"</span> : 2,
       <span class="stringliteral">"Minor"</span> : 8,
       <span class="stringliteral">"Stable"</span> : <span class="keyword">true</span>
     },
     <span class="stringliteral">"Languages"</span> :
     [
       <span class="stringliteral">"C++"</span>,
       <span class="stringliteral">"Phyton"</span>,
       <span class="stringliteral">"Perl"</span>,
       <span class="stringliteral">"C#/Net"</span>
     ]
   }
 }
</pre></div><p>
We can retrieve the values using several access methods as explained in the following code fragment:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// the JSON text, stored in a wxString object</span>
  wxString document( _T( <span class="stringliteral">"/************\n  This is a ...... "</span>));

  <span class="comment">// construct the JSON root object</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>  root;

  <span class="comment">// construct a JSON parser</span>
  <a class="code" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> reader;

  <span class="comment">// now read the JSON text and store it in the 'root' structure</span>
  <span class="comment">// check for errors before retreiving values...</span>
  <span class="keywordtype">int</span> numErrors = reader.<a class="code" href="classwxJSONReader.html#d5c6e801d57bb3457684c49fdff39758" title="Parse the JSON document.">Parse</a>( document, &amp;root );
  <span class="keywordflow">if</span> ( numErrors &gt; 0 )  {
    cout &lt;&lt; <span class="stringliteral">"ERROR: the JSON document is not well-formed"</span> &lt;&lt; endl;
    <span class="keyword">const</span> wxArrayString&amp; errors = reader.<a class="code" href="classwxJSONReader.html#47d62c6f839f755da719b4e8a5fc62ba" title="Return a reference to the error message&amp;#39;s array.">GetErrors</a>();
    <span class="comment">// now print the errors array</span>
    ...
    <span class="keywordflow">return</span>;
  }

  <span class="comment">// get the 'License' value</span>
  wxString license  = root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"License"</span>].<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>();

  <span class="comment">// check if a 'Version' value is present</span>
  <span class="keywordtype">bool</span> hasMember = root[<span class="stringliteral">"wxWidgets"</span>].<a class="code" href="classwxJSONValue.html#7b894f93a38691dc44c723c072b100b3" title="Return TRUE if the object contains an element at the specified index.">HasMember</a>( <span class="stringliteral">"Version"</span> );

  <span class="comment">// get the major version value as an integer</span>
  <span class="keywordtype">int</span> majorVer = root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Version"</span>][<span class="stringliteral">"Major"</span>].<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();

  <span class="comment">// get the minor version; if the value does not exists, the</span>
  <span class="comment">// default value of ZERO is returned</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> defaultValue( 0 );
  <span class="keywordtype">int</span> minorVer = root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Version"</span>].<a class="code" href="classwxJSONValue.html#fa38ce831d893208d26934d5439b7388" title="Return a value or a default value.">Get</a>( <span class="stringliteral">"Minor"</span>, defaultValue).<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();

  <span class="comment">// the same as above, but directly constructing the default value</span>
  <span class="keywordtype">int</span> minorVer = root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Version"</span>].<a class="code" href="classwxJSONValue.html#fa38ce831d893208d26934d5439b7388" title="Return a value or a default value.">Get</a>( <span class="stringliteral">"Minor"</span>, <a class="code" href="classwxJSONValue.html#b297ae154241e77c41f61af52d5d653f" title="Constructors.">wxJSONValue</a>( 0)).<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();

  <span class="comment">// now retrive the array of supported languages</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> languages = root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Languages"</span>];

  <span class="comment">// before obtaining the array of strings, we check that the type</span>
  <span class="comment">// of the 'language' object is an array</span>
  <span class="comment">// NOTE: this is not strictly necessary.</span>
  <span class="keywordtype">bool</span> isArray = languages.<a class="code" href="classwxJSONValue.html#379ac1a8d9ef32e2d674dd8e9e0aa924" title="Return TRUE if the type of the value stored is an array type.">IsArray</a>();

  wxArrayString supportedLanguages;
  <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; languages.<a class="code" href="classwxJSONValue.html#da3c7903ca595c195d501cbdcbf6b706" title="Return the size of the array or map stored in this value.">Size</a>() i++ ) {
    supportedLanguages.Add( languages[i].<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>());
  }

  <span class="comment">// finally, we get an array of all member's names of the 'wxWidgets'</span>
  <span class="comment">// item. The string array will contain (maybe not in this order):</span>
  <span class="comment">// </span>
  <span class="comment">//   Description</span>
  <span class="comment">//   License</span>
  <span class="comment">//   Version</span>
  <span class="comment">//   Languages</span>
  <span class="comment">//</span>
  wxArrayString memberNames = root[<span class="stringliteral">"wxWidgets"</span>].<a class="code" href="classwxJSONValue.html#589b0f879dd3169ee2e7cf4fbed5fe8b" title="Return the array of keys of this JSON object.">GetMemberNames</a>();
  
  <span class="comment">// starting from version 1.1 you can also get the value and check</span>
  <span class="comment">// if it is of the expected type in only one call:</span>
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">if</span> ( !root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Version"</span>][<span class="stringliteral">"Major"</span>].<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>( i ))  {
     cout &lt;&lt; <span class="stringliteral">"Error: major version is not of type INT"</span>;
  }
</pre></div><p>
You can also use iterators to get all key/value objects in a JSON value, provided that the value (that may also be the root value) is of type key/value. This is an example: <div class="fragment"><pre class="fragment">{
    <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> root;
    root[_T(<span class="stringliteral">"first"</span>)] = 1;
    root[_T(<span class="stringliteral">"second"</span>)] = 2;
    root[_T(<span class="stringliteral">"third"</span>)] = 3;
    root[_T(<span class="stringliteral">"fourth"</span>)] = 4;
    
    <span class="comment">// the following works in both enabled and disabled STL</span>
    
    <span class="keyword">const</span> <a class="code" href="jsonval_8h.html#fd467c09a9467362fe6ede843fa5333a">wxJSONInternalMap</a>* map = root.<a class="code" href="classwxJSONValue.html#f4740508a910a5ac96ca8c81a01037e2" title="Return the stored value as a map object.">AsMap</a>();
    wxASSERT( map );    <span class="comment">// check that the type is correct</span>
    
    wxJSONInternalMap::const_iterator iter;
    <span class="keywordflow">for</span> ( iter = map-&gt;begin(); iter != map-&gt;end(); iter++ ) {
        <span class="keyword">const</span> wxJSONInternalMap::value_type&amp; v = *iter;
        <span class="comment">// 'v.first' is the key</span>
        <span class="comment">// 'v.second' is the wxJSONValue object</span>
    }
}
</pre></div><p>
The <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> class's constructor has some parameters that control how much error-tolerant should the parser be. By default, the parser is very tolerant about non fatal errors which are reported as <em>warnings</em>. For more information see the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> class's description. In addition to reading from a <b>wxString</b> object, you can also read the JSON text from a <b>wxInputStream</b> object. The difference is that the text read from a stream must be encoded in UTF-8 format while the text stored in a string object is encoded in different ways depending on the platform and the build mode: in Unicode builds, strings are stored in UCS-2 format on Windows and UCS-4 on GNU/Linux; in ANSI builds, the string object contains one-byte, locale dependent characters. To know more about Unicode / ANSI read <a class="el" href="wxjson_tutorial.html#wxjson_tutorial_unicode">Unicode support in wxJSON</a><p>
Adding new values or changing the value of existing JSON-value objects is also very simple. The following code fragment shows some examples:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// upgrade the minor version</span>
  root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Version"</span>][<span class="stringliteral">"Minor"</span>] = 9;

  <span class="comment">// create the new 'URL' item</span>
  root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"URL"</span>] = <span class="stringliteral">"http://www.wxwidgets.org"</span>;

  <span class="comment">// append a new supported language in the 'Language' array</span>
  root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Languages"</span>].<a class="code" href="classwxJSONValue.html#9ae9caef81e6e2f5b10853cdcbccb33c" title="Append the specified value in the array.">Append</a>( <span class="stringliteral">"Java"</span> );

  <span class="comment">// creates the new 'Authors' array.</span>
  <span class="comment">// creating an array is just as simple as using the 'Append()'</span>
  <span class="comment">// member function.</span>
  root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Authors"</span>].<a class="code" href="classwxJSONValue.html#9ae9caef81e6e2f5b10853cdcbccb33c" title="Append the specified value in the array.">Append</a>( <span class="stringliteral">"J. Smart"</span> );
  root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Authors"</span>].<a class="code" href="classwxJSONValue.html#9ae9caef81e6e2f5b10853cdcbccb33c" title="Append the specified value in the array.">Append</a>( <span class="stringliteral">"V. Zeitling"</span> );
  root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Authors"</span>].<a class="code" href="classwxJSONValue.html#9ae9caef81e6e2f5b10853cdcbccb33c" title="Append the specified value in the array.">Append</a>( <span class="stringliteral">"R. Roebling"</span> );
  ... and many others...

  <span class="comment">// you can also use subscripts to obtain the same result:</span>
  root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Authors"</span>][0] = <span class="stringliteral">"J. Smart"</span>;
  root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Authors"</span>][1] = <span class="stringliteral">"V. Zeitling"</span>;
  root[<span class="stringliteral">"wxWidgets"</span>][<span class="stringliteral">"Authors"</span>][2] = <span class="stringliteral">"R. Roebling"</span>;
  ... and many others...

  <span class="comment">// after the changes, we have to write the JSON object back</span>
  <span class="comment">// to its text representation</span>
  <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer;
  wxString     str;
  writer.<a class="code" href="classwxJSONWriter.html#2cebc74d641090c6946dac631b782f2e" title="Write the JSONvalue object to a JSON text.">Write</a>( root, str );

  <span class="comment">// if you use the default writer constructor the JSON text</span>
  <span class="comment">// output is human-readable (indented) but does not contain</span>
  <span class="comment">// the comment lines</span>
  <span class="comment">// if you want to keep the comment lines you have to pass</span>
  <span class="comment">// some parameters to the wxJSONWriter constructor</span>
  <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer2( <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5a67859cf6380120c9bec21de50adf446">wxJSONWRITER_STYLED</a> | <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b51c292ae7207bbe36ef0e805f942171a2">wxJSONWRITER_WRITE_COMMENTS</a> );
  wxString     str2;
  writer2.Write( root, str2 );
</pre></div><p>
The writer class's constructor has some parameters that allow you to control the <em>style</em> of the output. By default, the writer produces human-readable output with a three-space indentation for objects / arrays sub-items (as shown in the example text above) but it does not write comment lines. You can suppress indentation if, for example, the JSON text has to be sent over a network connection.<p>
Also note that in order to actually have comment lines written back to the JSON text document, you also have to store comments when reading the JSON text document. By default, the parser is error-tolerant and recognizes C/C++ comments but it ignores them. This means that you cannot rewrite them back regardless the flags used in the writer class. To know more about comment lines in JSONvalue objects, see <a class="el" href="wxjson_tutorial.html#wxjson_tutorial_comment">Using comment lines in wxJSON</a>.<p>
In addition to writing to a <b>wxString</b> object, you can also write to a <b>wxOutputStream</b> object. The difference is that the text written to streams is always encoded in UTF-8 format in both Unicode and ANSI builds while the text written to a string object is encoded in different ways depending on the platform and the build mode: in Unicode builds, strings are stored in UCS-2 format on Windows and UCS-4 on GNU/Linux; in ANSI builds, the string object contains one-byte, locale dependent characters. To know more about Unicode / ANSI read <a class="el" href="wxjson_tutorial.html#wxjson_tutorial_unicode">Unicode support in wxJSON</a><p>
Also note that the <a class="el" href="classwxJSONWriter.html#2cebc74d641090c6946dac631b782f2e" title="Write the JSONvalue object to a JSON text.">wxJSONWriter::Write()</a> function does not return a status code. This is OK for writing to a string object but when writing to streams, you have to check for errors. Because the wxJSON writer does not return error codes, you have to check for errors using the stream's memberfunctions, as in the following example code:<p>
<div class="fragment"><pre class="fragment">   <span class="comment">// construct the JSON value object and add values to it</span>
   <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> root;
   root[<span class="stringliteral">"key1"</span>] = <span class="stringliteral">"some value"</span>;

   <span class="comment">// write to a stream</span>
   wxMemoryOutputStream mem;
   <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer;
   writer.<a class="code" href="classwxJSONWriter.html#2cebc74d641090c6946dac631b782f2e" title="Write the JSONvalue object to a JSON text.">Write</a>( root, mem );

   <span class="comment">// use the stream's 'GetLastError()' function to know if the</span>
   <span class="comment">// write operation was successfull or not</span>
   wxStreamError err = mem.GetLastError();
   <span class="keywordflow">if</span> ( err != wxSTREAM_NO_ERROR )  {
     MessageBox( _T(<span class="stringliteral">"ERROR: cannot write the JSON text output"</span>));
   }
</pre></div><h3><a class="anchor" name="wxjson_tutorial_jsonpower">
The power and simplicity of JSON</a></h3>
I do not know much about XML but I think that JSON is really a valid alternative to it if you just need a simple format for data interchange. JSON is not suitable for describing complex documents: it can only handle data and it is specialized in handling progamming language's variables.<p>
I only would like to let you know how much simple is wxJSON: the subscript operators used to access JSON values returns a reference to the JSON value itself thus allowing to have multiple subscripts. Moreover, if the accessed value does not exists, it will be created and a reference to the newly created value is returned. This feature lets you use constructs such as the following:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> value;
  value[<span class="stringliteral">"key-1"</span>][<span class="stringliteral">"key-2"</span>][<span class="stringliteral">"key-3"</span>][4] = 12;
  
  <span class="comment">// now write to JSON text</span>
  <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer;
  wxString     jsonText;
  writer.<a class="code" href="classwxJSONWriter.html#2cebc74d641090c6946dac631b782f2e" title="Write the JSONvalue object to a JSON text.">Write</a>( root, jsonText );
</pre></div><p>
Because <code>value</code> does not contain any of the specified keys (for objects) and elements (for the array), they will be created. The JSON text output of the code fragment seen above is as follows:<p>
<div class="fragment"><pre class="fragment">  {
    <span class="stringliteral">"key-1"</span> :  {
       <span class="stringliteral">"key-2"</span> :  {
          <span class="stringliteral">"key-3"</span> : [
             null,
             null,
             null,
             null,
             12
          ]
        }
     }
  }
</pre></div><h2><a class="anchor" name="wxjson_tutorial_ex2">
Example 2: a configuration file</a></h2>
We start by using JSON for an application's configuration file. There are many formats for storing application's configuration data. I remember when there was MS-DOS: each application used its own, unreadable and proprietary format (it was a nightmare). Next came Windows 3: it had a better way for storing application's configuration data; they were kept in an .INI file which contains simple ASCII text. This was an improvement because it was easier for humans to fine-tuning application's behaviour.<p>
In this example we use JSON to store the configuration data of a simple web server application. If you take a look at the Apache config file you will notice that our example looks very similar (but much more human readable).<p>
Our server is a neverending application and it is not interactive: it reads its configuration at startup and when a signal is sent to it. Using JSON for the configuration data is a good choice because it is easy for humans to write the JSON text document. Below we find our webserver's configuration file:<p>
<div class="fragment"><pre class="fragment"> {
   <span class="comment">// global configuration</span>
   <span class="stringliteral">"Global"</span> :  {
     <span class="stringliteral">"DocumentRoot"</span>  : <span class="stringliteral">"/var/www/html"</span>,
     <span class="stringliteral">"MaxClients"</span>    : 250,
     <span class="stringliteral">"ServerPort"</span>    : 80,
     <span class="stringliteral">"ServerAddress"</span> : 0.0.0.00
     <span class="stringliteral">"MaxRequestsPerClient"</span>  : 1000
   }

   <span class="comment">// an array of objects that describes the modules that has to</span>
   <span class="comment">// be loaded at startup</span>
   <span class="stringliteral">"Modules"</span> : [
      {
        <span class="stringliteral">"Name"</span>    : <span class="stringliteral">"auth_basic"</span>,
        <span class="stringliteral">"File"</span>    : <span class="stringliteral">"modules/mod_auth_basic.so"</span>,
        <span class="stringliteral">"OnStart"</span> : <span class="keyword">true</span>
      },
      {
        <span class="stringliteral">"Name"</span>    : <span class="stringliteral">"auth_digest"</span>,
        <span class="stringliteral">"File"</span>    : <span class="stringliteral">"modules/mod_auth_digest.so"</span>,
        <span class="stringliteral">"OnStart"</span> : <span class="keyword">true</span>
      },
      {
        <span class="stringliteral">"Name"</span>    : <span class="stringliteral">"auth_file"</span>,
        <span class="stringliteral">"File"</span>    : <span class="stringliteral">"modules/mod_auth_file.so"</span>,
        <span class="stringliteral">"OnStart"</span> : <span class="keyword">false</span>
      },
   ]

   <span class="comment">// Main server configuration</span>
   <span class="stringliteral">"Server"</span> :       {
      <span class="stringliteral">"Admin"</span> : <span class="stringliteral">"root@localhost.localdomain"</span>
      <span class="stringliteral">"Name"</span>  : <span class="stringliteral">"www.example.com"</span>
   },

   <span class="comment">// The description of directories and their access permissions</span>
   <span class="stringliteral">"Diretory"</span>  : [
      {
         <span class="stringliteral">"Path"</span>       : <span class="stringliteral">"/var/www/html"</span>,
         <span class="stringliteral">"AllowFrom"</span>  : <span class="stringliteral">"ALL"</span>,
         <span class="stringliteral">"DenyFrom"</span>   : null,
         <span class="stringliteral">"Options"</span> :     {
            <span class="stringliteral">"Multiviews"</span>    : <span class="keyword">false</span>,
            <span class="stringliteral">"Indexes"</span>       : <span class="keyword">true</span>,
            <span class="stringliteral">"FollowSymLink"</span> : <span class="keyword">false</span>
         }
      }
   ]
 }
</pre></div><p>
I think that the file is self-explanatory. I do not want to write the code of the whole web-server application: I only want to show you how to read the configuration data.<p>
When the application starts, it calls a function that reads the configuration file and returns ZERO if there was no error or an exit status code if the file is not correct. The function may be similar to the following one:<p>
<div class="fragment"><pre class="fragment">  <span class="keywordtype">int</span> ReadConfig( wxInputStream&amp; jsonStream )
  {
    <span class="comment">// comment lines are recognized by the wxJSON library and</span>
    <span class="comment">// can also be stored in the JSON value objects they refer to</span>
    <span class="comment">// but this is not needed by our application because the</span>
    <span class="comment">// config file is written by hand by the website admin</span>
    <span class="comment">// so we use the default ctor of the parser which recognizes</span>
    <span class="comment">// comment lines but do not store them</span>
    <a class="code" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> reader;
    wxJSONvalue  root;
    <span class="keywordtype">int</span> numErrors = reader.<a class="code" href="classwxJSONReader.html#d5c6e801d57bb3457684c49fdff39758" title="Parse the JSON document.">Parse</a>( jsonStream, root );
    <span class="keywordflow">if</span> ( numErrors &gt; 0 )  {
      <span class="comment">// if there are errors in the JSON document, print the</span>
      <span class="comment">// errors and return a non-ZERO value</span>
      <span class="keyword">const</span> wxArrayString&amp; errors = reader.<a class="code" href="classwxJSONReader.html#47d62c6f839f755da719b4e8a5fc62ba" title="Return a reference to the error message&amp;#39;s array.">GetErrors</a>();
      <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; numErrors; i++ )  {
        cout &lt;&lt; errors[i] &lt;&lt; endl;
      }
      <span class="keywordflow">return</span> 1;
    }

    <span class="comment">// if the config file is syntactically correct, we retrieve</span>
    <span class="comment">// the values and store them in application's variables</span>
    gs_docRoot = root[<span class="stringliteral">"Global"</span>][<span class="stringliteral">"DocumentRoot"</span>].AsString();

    <span class="comment">// we use the Get() memberfunction to get the port on which</span>
    <span class="comment">// the server listens. If the parameter does not exist in the</span>
    <span class="comment">// JSON value, the default port 80 is returned</span>
    wxJSONvalue defaultPort = 80;
    gs_serverPort = root[<span class="stringliteral">"Global"</span>].Get( <span class="stringliteral">"ServerPort"</span>, defaultPort ).AsInt();

    <span class="comment">// the array of modules is processed in a different way: for</span>
    <span class="comment">// every module we print its name and the 'OnStart' flag.</span>
    <span class="comment">// if the flag is TRUE, we load it.</span>
    <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> modules = root[<span class="stringliteral">"Modules"</span>];

    <span class="comment">// check that the 'Modules' value is of type ARRAY</span>
    <span class="keywordflow">if</span> ( !modules.<a class="code" href="classwxJSONValue.html#379ac1a8d9ef32e2d674dd8e9e0aa924" title="Return TRUE if the type of the value stored is an array type.">IsArray</a>() ) {
      cout &lt;&lt; <span class="stringliteral">"ERROR: \'modules\' must be a JSON array"</span> &lt;&lt; endl;
      <span class="keywordflow">return</span> 1;
    }

    <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; modules.<a class="code" href="classwxJSONValue.html#da3c7903ca595c195d501cbdcbf6b706" title="Return the size of the array or map stored in this value.">Size</a>(); i++ )  {
      cout &lt;&lt; <span class="stringliteral">"Processing module: "</span> &lt;&lt; modules[i][<span class="stringliteral">"Name"</span>].<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>() &lt;&lt; endl;
      <span class="keywordtype">bool</span> load =  modules[i][<span class="stringliteral">"OnStart"</span>].<a class="code" href="classwxJSONValue.html#215dd59ebc4e6ab0e75caa3421cc9ed6" title="Return the stored value as a boolean.">AsBool</a>();
      cout &lt;&lt; <span class="stringliteral">"Load module? "</span> &lt;&lt; ( load ? <span class="stringliteral">"YES"</span> : <span class="stringliteral">"NO"</span> ) &lt;&lt; endl;
      <span class="keywordflow">if</span> ( load )  {
        LoadModule( modules[i][<span class="stringliteral">"File"</span>].Asstring());
      }
    }
    <span class="comment">// return a ZERO value: it means success.</span>
    <span class="keywordflow">return</span> 0;
  }
</pre></div><h2><a class="anchor" name="wxjson_tutorial_ex3">
Example 3: Describing a table</a></h2>
How many times did you use a table in your application? I know the answer: many times. So the best thing would be to write a general-purpose panel window that is capable to show every possible table and table's format.<p>
It is not hard to write a similar panel: we only need to implement some basic data that will be passed as parameters to the panel window:<p>
<ul>
<li>the column's names </li>
<li>the column's alignment, if not implicit in the data type </li>
<li>the type of data in each column </li>
<li>the border thickness, if any </li>
<li>the column's width in pixels or in panel's width percentage, if needed </li>
<li>a bidimensional array that contains the actual data that has to be displayed</li>
</ul>
A more complex work is to define a good data structure that holds this informations and the table's data themselves. Because we have to show many different tables in our application, there is not a general structure suitable for our needs because the data type of each column may vary from table to table. But we need something to pass as a parameter to our general-purpose table-viewer panel.<p>
The answer could be: use a JSON formatted wxString object. We define a JSON object that contains two main objects:<p>
<ul>
<li>a description of the columns </li>
<li>the content of the rows</li>
</ul>
Below you find the format of the JSON text that describes a table containing three columns and three rows:<p>
<div class="fragment"><pre class="fragment"> {
   <span class="stringliteral">"Border"</span>  : 1,

   <span class="stringliteral">"Columns"</span> : [ 
     {
       <span class="stringliteral">"Name"</span>   : <span class="stringliteral">"City"</span>,
       <span class="stringliteral">"Width"</span>  : 50,
       <span class="stringliteral">"Unit"</span>   : <span class="stringliteral">"Percentage"</span>
     },
     {
       <span class="stringliteral">"Name"</span>      : <span class="stringliteral">"Temperature"</span>,
       <span class="stringliteral">"Width"</span>     : 20,
       <span class="stringliteral">"Unit"</span>      : <span class="stringliteral">"Percentage"</span>
     },
     {
       <span class="stringliteral">"Name"</span>      : <span class="stringliteral">"Date"</span>,
       <span class="stringliteral">"Width"</span>     : 30,
       <span class="stringliteral">"Unit"</span>      : <span class="stringliteral">"Percentage"</span>
       <span class="stringliteral">"Alignment"</span> : <span class="stringliteral">"center"</span>
     }
  ]

   <span class="stringliteral">"Rows"</span> : [
     [ <span class="stringliteral">"Baltimora"</span>, 20, <span class="stringliteral">"20 july"</span> ],
     [ <span class="stringliteral">"New York"</span>, 25, <span class="stringliteral">"23 july"</span> ],
     [ <span class="stringliteral">"Los Angeles"</span>, 29, <span class="stringliteral">"25 july"</span> ]
   ]
 }
</pre></div><p>
Note that there is no need to specify the type of the data contained in each column because the JSON value object already carries it.<p>
The code for displaying a table that is described in the above JSON text is similar to this one:<p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">void</span> DisplayTable( <span class="keyword">const</span> wxString&amp; jsonText )
 {
   <a class="code" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> reader;
   wxJSONvalue  root;
   <span class="keywordtype">int</span> numErrors = reader.<a class="code" href="classwxJSONReader.html#d5c6e801d57bb3457684c49fdff39758" title="Parse the JSON document.">Parse</a>( jsonText, root );
   <span class="keywordflow">if</span> ( numErrors &gt; 0 )  {
     <span class="comment">// if there are errors in the JSON document return</span>
     <span class="keywordflow">return</span>;
   {

   <span class="comment">// now display the column names</span>
   wxJSONvalue columns = root[<span class="stringliteral">"Columns"</span>];
   <span class="keywordtype">int</span> border = root[<span class="stringliteral">"Border"</span>].AsInt();
   <span class="keywordtype">int</span> width; <span class="keywordtype">string</span> align;
   <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i = 0; i &lt; columns.Size(); i++ )  {
     width = columns[i][<span class="stringliteral">"Width"</span>].AsInt();
     DisplayColName( columns[i][<span class="stringliteral">"Name"</span>].<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>(), width );
   }

   <span class="comment">// and now we display the data in the rows</span>
   <span class="comment">// note that we use a predefined alignment for data</span>
   <span class="comment">// unless a specific alignment is set:</span>
   <span class="comment">//</span>
   <span class="comment">//  left for strings</span>
   <span class="comment">//  right for numbers</span>

   <span class="comment">// the bidimensional array</span>
   <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> rows = root[<span class="stringliteral">"Rows"</span>];

   <span class="comment">// the string that has to be displayed in the table's cell</span>
   <span class="keywordtype">string</span> valueString;

   <span class="comment">// the default alignment: it is set depending on the data type</span>
   <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> defaultAlign;

   <span class="comment">// for all rows ...</span>
   <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> x = 0; x &lt; rows.<a class="code" href="classwxJSONValue.html#da3c7903ca595c195d501cbdcbf6b706" title="Return the size of the array or map stored in this value.">Size</a>(); x++ )  {

     <span class="comment">// .. and for all columns in the row</span>
     <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> y = 0; y &lt; rows[x].<a class="code" href="classwxJSONValue.html#da3c7903ca595c195d501cbdcbf6b706" title="Return the size of the array or map stored in this value.">Size</a>(); y++ )  {
       <span class="comment">// get the width of the column</span>
       width = columns[y][<span class="stringliteral">"Width"</span>].AsInt();

       <span class="comment">// get the value object</span>
       <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> value = rows[x][y];

       <span class="comment">// check the type of the data</span>
       <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592" title="The type of the value held by the wxJSONRefData class.">wxJSONValue::wxJSONType</a> type = value.<a class="code" href="classwxJSONValue.html#464f3962a62fc31bd9b096ff7401495a" title="Return the type of the value stored in the object.">GetType</a>();
       <span class="keywordflow">switch</span> ( type )  {
         <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592860de19a423bdb9c0470314825cc2797">wxJSONTYPE_NULL</a> :
           <span class="comment">// display an empty string</span>
           valueString.clear();;
           <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb9759243e56dd76e79e8d1c16f80523fc3234b">wxJSONTYPE_INT</a> :
         <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592185982daad25bfa5099c4270bcb63659">wxJSONTYPE_UINT</a> :
         <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592da62a1242eec87f4cb590a4913f4c6b2">wxJSONTYPE_DOUBLE</a> :
           <span class="comment">// numeric values are right-aligned</span>
           defaulAlign = <span class="stringliteral">"right"</span>;
           align = columns[y].Get( <span class="stringliteral">"Align"</span>, defaultAlign ).AsString();
           valueString = value.<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>();
           <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb975926099bcd86072cc550ac4c5f822a09dd2">wxJSONTYPE_STRING</a> :
         <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb9759239b85b9b71648bcc92088541b6229b03">wxJSONTYPE_CSTRING</a> :
           defaulAlign = <span class="stringliteral">"left"</span>;
           align = columns[y].Get( <span class="stringliteral">"Align"</span>, defaultAlign ).AsString();
           valueString = value.<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>();
           <span class="keywordflow">break</span>;
         <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592959cf34a07f639e46ee8a9c8c3479739">wxJSONTYPE_BOOL</a> :
           defaulAlign = <span class="stringliteral">"center"</span>;
           align = columns[y].Get( <span class="stringliteral">"Align"</span>, defaultAlign ).AsString();
           valueString = value.<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>();
           <span class="keywordflow">break</span>;
       }
       <span class="comment">// now that we have the alignment, the column's width and the </span>
       <span class="comment">// value of the data as a string:</span>
       <span class="comment">// note that numeric data are converted to a decimal string</span>
       <span class="comment">// and boolean values are converted to 'TRUE' or 'FALSE' when you</span>
       <span class="comment">// use the wxJSONValue::AsString() memberfunction</span>
       DisplayValue( valueString, width, align );

     }   <span class="comment">// continue for all columns</span>
   }     <span class="comment">// continue for all rows</span>
 }
</pre></div><p>
JSON format is very flexible: in future we can add new features to the application. For example we may decide that our general-purpose table-viewer panel will let the user to change the values in the table rows but only for some specific columns.<p>
We add a new item in the <b>Columns</b> array descriptors: the <b>Editable</b> flag which is a boolean type. Example:<p>
<div class="fragment"><pre class="fragment">   <span class="stringliteral">"Columns"</span> : [ 
     {
       <span class="stringliteral">"Name"</span>   : <span class="stringliteral">"Temperature"</span>,
       <span class="stringliteral">"Width"</span>  : 50,
       <span class="stringliteral">"Unit"</span>   : <span class="stringliteral">"Percentage"</span>,
       <span class="stringliteral">"Editable"</span> : <span class="keyword">true</span>
     },
</pre></div><p>
Note that this new format of our table description is compatible in <em>both</em> <em>directions:</em> it is normal that a new version of the application can read and handle <em>old-style</em> data but it is not very easy to maintain the old application compatible with a new data format that was introduced in a new version.<p>
In our example, the simplicity and flexibility of JSON make the old application capable of reading the new format of JSON data. Of course, the data are not editable because the old application does not permit this operation. The old version of the application simply ignores the existance of the new <b>Editable</b> flag so that the JSON text can be read and processed as in the previous version.<h2><a class="anchor" name="wxjson_tutorial_get">
Obtaining values from JSON value class</a></h2>
The <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class defines functions for checking what type of data is stored in the JSON object and for getting the value stored in the class. This topic has totally changed from versions 0.x to versions 1.x.<p>
In older 0.x versions you can get a value stored in the JSON value object in a type that is different from the one that is actually stored provided that the two types are compatible. For example, if a value contains an integer type of value -1, you can get the value as an integer or as a double, or as a string:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v( -1 );

  <span class="keywordtype">int</span> i      = v.<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();    <span class="comment">// returns -1</span>
  <span class="keywordtype">double</span> d   = v.<a class="code" href="classwxJSONValue.html#abfbf017df18677aa74d90bb36c6bb14" title="Return the stored value as a double.">AsDouble</a>(); <span class="comment">// returns -1.0</span>
  wxString s = v.<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>(); <span class="comment">// returns "-1"</span>
</pre></div><p>
This is no longer supported in new 1.x versions: all <b>AsXxxxxx()</b> functions return the stored value without reinterpreting the bits stored in memory so when you call the <b>AsDouble()</b> function on a value object that contains the integer -1 (all bits set), you get a <b>NaN</b> because all bits set in a double type represent a NaN:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v( -1 );

  <span class="keywordtype">int</span> i      = v.<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();    <span class="comment">// returns -1</span>
  <span class="keywordtype">double</span> d   = v.<a class="code" href="classwxJSONValue.html#abfbf017df18677aa74d90bb36c6bb14" title="Return the stored value as a double.">AsDouble</a>(); <span class="comment">// returns NaN</span>
  wxString s = v.<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>(); <span class="comment">// returns "-1"</span>
</pre></div><p>
The only exceptions to this rule are the functions:<p>
<ul>
<li><b>AsString()</b> </li>
<li><b>AsCString()</b> </li>
</ul>
The first function returns a string representation of all types included arrays and objects. The second function returns:<p>
<ul>
<li>the pointer returned by <b>wxString::c_str()</b> if the JSON value object contains a wxString object. </li>
<li>the pointer stored in the wxJSONRefData::m_value.m_valCString if the JSON value object contains a <em>pointer-to-static-string</em> i.e. the object is of type wxJSONTYPE_CSTRING (see <a class="el" href="pg_json_internals.html#json_internals_cstring">wxJSON internals: the C string type</a> for details about c-string type) </li>
<li>a NULL pointer in all other cases.</li>
</ul>
<h3><a class="anchor" name="json_internals_integer_newas">
The new AsXxxxxx(T&amp;) function.</a></h3>
In order to get the correct value from a JSON value object you should always call the <b>IsXxxxxx()</b> function before getting the value and, if it is of the wrong type you should notify the user:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v( _T(<span class="stringliteral">"100"</span>));
  <span class="keywordtype">int</span> i = 10;           <span class="comment">// the default value</span>
  <span class="keywordflow">if</span> ( v.<a class="code" href="classwxJSONValue.html#2872aee9886b348ac438e758d0f9bf18" title="Return TRUE if the type of the value stored is integer.">IsInt</a>() )  {
    i = v.<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();
  }
  <span class="keywordflow">else</span>  {
    wxMessageBox( _T(<span class="stringliteral">"Warning: parameter is of the wrong type - using default"</span>)) ;
  }
</pre></div><p>
Starting from version 1.1 you can get the value of a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object and check if it is of the expected type in only one call using an overloaded version of the <code>AsXxxxxxx</code> functions which takes the expected type as a parameter and returns TRUE if the value actually stored in the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object is of that type (see wxJSONValue::AsInt(int&amp;) for details). For example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v( _T(<span class="stringliteral">"100"</span>));
  <span class="keywordtype">int</span> i = 10;           <span class="comment">// the default value</span>
  
  <span class="keywordflow">if</span> ( !value.<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>( i ) ) {
    wxMessageBox( _T(<span class="stringliteral">"Warning: parameter is of the wrong type - using default"</span>)) ;
  }
</pre></div><p>
You can also use the <a class="el" href="classwxJSONValue.html#464f3962a62fc31bd9b096ff7401495a" title="Return the type of the value stored in the object.">wxJSONValue::GetType()</a> function to get directly the type of the value which returns a <b>wxJSONType</b> type that can be used in a <b>switch</b> statement:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> value( 100 );
  <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592" title="The type of the value held by the wxJSONRefData class.">wxJSONType</a> type = value.<a class="code" href="classwxJSONValue.html#464f3962a62fc31bd9b096ff7401495a" title="Return the type of the value stored in the object.">GetType</a>();
  <span class="keywordflow">switch</span> ( type )  {
    <span class="comment">// use 64-bit int for all signed integers</span>
    <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb9759243e56dd76e79e8d1c16f80523fc3234b">wxJSONTYPE_INT</a> :
    <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb975926d18996b68e2d558d758de5880199f3d">wxJSONTYPE_SHORT</a> :
    <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592228ea16303dd04648d0652be7e3cffb1">wxJSONTYPE_LONG</a> :
    <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb975929bbd7d40903699bf1967f70c123b7483">wxJSONTYPE_INT64</a> :
      wxInt64 i64 = value.<a class="code" href="classwxJSONValue.html#a057c7dcb48e052a1863ef069469295b" title="Return the numeric value as a 64-bit integer.">AsInt64</a>();
      <span class="keywordflow">break</span>;
      
    <span class="comment">// use 64-bit uint for all unsigned integers</span>
    <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592185982daad25bfa5099c4270bcb63659">wxJSONTYPE_UINT</a> :
    <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592ccb126025d6dfade618ac2d99af7576c">wxJSONTYPE_USHORT</a> :
    <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592f501eb6c04a527023791f3dd2127319f">wxJSONTYPE_ULONG</a> :
    <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb9759233244321b5418d38bad222c5a1ada052">wxJSONTYPE_UINT64</a> :
      wxUint64 i64 = value.<a class="code" href="classwxJSONValue.html#c6956d7d836e1b416979b39cdf5c2c2b" title="Return the numeric value as a 64-bit unsigned integer.">AsUInt64</a>();

    <span class="keywordflow">case</span> <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb97592da62a1242eec87f4cb590a4913f4c6b2">wxJSONTYPE_DOUBLE</a> :
      <span class="keywordtype">double</span> d = value.<a class="code" href="classwxJSONValue.html#abfbf017df18677aa74d90bb36c6bb14" title="Return the stored value as a double.">AsDouble</a>();

    ... always specify ALL the possible types ...

    <span class="keywordflow">default</span> :
      wxFAIL_MSG( _T(<span class="stringliteral">"Unexpected value type"</span>));
  }
</pre></div><p>
What happens if I get the wrong type?<p>
As explained earlier, the <code>wxJSONValue::AsXxxxxx()</code> functions just return the content of the memory area as it apears without trying to promote the stored type to another type even when they are compatible. The conseguence is that the function returns a wrong value. Example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v( -1 );

  <span class="comment">// returns -1 (OK): the IsInt() returns TRUE</span>
  <span class="keywordtype">int</span> i      = v.<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();

  <span class="comment">// returns NaN (wrong): IsDouble() returns FALSE</span>
  <span class="keywordtype">double</span> d   = v.<a class="code" href="classwxJSONValue.html#abfbf017df18677aa74d90bb36c6bb14" title="Return the stored value as a double.">AsDouble</a>();

  <span class="comment">// returns 4294967295 (wrong) IsUInt() returns FALSE</span>
  <span class="keywordtype">unsigned</span> u = v.<a class="code" href="classwxJSONValue.html#154b8956ebca83e3ecd503969cbef6b2" title="Return the stored value as a unsigned int.">AsUInt</a>();

  <span class="comment">// returns 65535 (wrong) IsUShort() returns FALSE</span>
  <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> h  = v.<a class="code" href="classwxJSONValue.html#49f3f0bf477f228efdac321954e2ce03" title="Returns the value as a unsigned short integer.">AsUShort</a>();

  <span class="comment">// returns "-1" (OK) IsString() returns FALSE; this is an exception</span>
  wxString s  = v.<a class="code" href="classwxJSONValue.html#46de573c4f4e5afa5b3a1577135c2250" title="Return the stored value as a wxWidget&amp;#39;s string.">AsString</a>();

  <span class="comment">// returns a NULL pointer IsCString() returns FALSE</span>
  wxChar* c  = v.<a class="code" href="classwxJSONValue.html#ee2b1ea5667255f1c157342cd4177862" title="Return the stored value as a pointer to a static C string.">AsCString</a>();
</pre></div><p>
The above return values are just examples which demonstrate the wrong results. When you store something in the <code>m_value</code> data member of the JSON value object, the actual return value is undefined if incorrectly accessed. For example, if a positive integer value of 100,000 (0x186A0) is stored in a JSON value object and we try to access it as a SHORT we get:<p>
<ul>
<li><b>0x86A0</b> (34,464) in a little-endian machine </li>
<li><b>0x0</b> in a 64-bit big-endian machine </li>
<li><b>0x1</b> in a 32-bit big-endian machine</li>
</ul>
However, in debug builds all <b>AsXxxxxx()</b> functions ASSERT that the corresponding <b>IsXxxxx</b> functions return TRUE so avoiding type mismatch errors. The ASSERTION failures does not occur in release builds.<p>
So now I <b>cannot</b> get the value as a compatible type? Oh no, you can <b>get</b> it but you have to <b>access</b> it using the correct type. Example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 10 );    <span class="comment">// a SHORT</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2( 100.00); <span class="comment">// a DOUBLE</span>
  
  <span class="keywordtype">double</span> d = v1.<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();   <span class="comment">// OK, a SHORT accessed as INT</span>
  <span class="keywordtype">int</span>    i = v2.AsInt();   <span class="comment">// WRONG! a double accessed as INT</span>
  <span class="keywordtype">int</span>  i2 = v2.AsDouble(); <span class="comment">// OK, a double accessed as DOUBLE, but the compiler warns you</span>
  
  <span class="keywordtype">int</span>  i3 = (int) v2.AsDouble();  <span class="comment">// OK, no warning, if you know what you are doing</span>
</pre></div><p>
Starting from version 0.5 the wxJSON library supports 64-bits integers on platforms that have native support for this. If the library is compiled with the 64-bits support enabled, the JSON value class defines functions in order to let the user know the storage needed by the integer value (16-, 32-bits or 64-bits). To know more about this topic read <a class="el" href="pg_json_internals.html#json_internals_integer">64-bits and 32-bits integers</a>.<h2><a class="anchor" name="wxjson_tutorial_read_numbers">
How numbers are read from JSON text.</a></h2>
If 64-bits support is enabled in the wxJSON library, reading values from JSON text may have different results. If a numeric value is too large for 32-bits integer storage:<p>
<ul>
<li>it will be stored as a double data type in versions &lt;= 0.4 </li>
<li>it will be stored as integer if it fits in a 64-bit integer in versions &gt;= 0.5</li>
</ul>
When the wxJSON parser reads a token that start with a digit or with a minus or plus sign, it assumes that the value read is a number and it tries to convert it to:<p>
<ul>
<li>first tries signed integer conversion </li>
<li>if the number does not fit, tries unsigned integer </li>
<li>if the number does not fit, tries double </li>
<li>if double is unsuccessfull, an error is reported</li>
</ul>
Note that if 64-bits storage is enabled, the wxJSON parser, does not try to convert numeric tokens in a 32-bits integer but immediatly tries 64-bits storage. This has the conseguence that numeric values that are between LONG_MAX + 1 and ULONG_MAX are stored as signed integers in a 64-bits environment and as unsigned integers in a 32-bits environment.<p>
Examples:<p>
<div class="fragment"><pre class="fragment">  {
    <span class="comment">// in a 32 bits integer environment</span>
    2147483647  <span class="comment">// INT_MAX: read as a signed long integer</span>
    2147483648  <span class="comment">// INT_MAX + 1: read as a unsigned long</span>

   -2147483648  <span class="comment">// INT_MIN: read as a signed long integer</span>
    4294967295  <span class="comment">// UINT_MAX: read as a unsigned long integer</span>
    4294967296  <span class="comment">// UINT_MAX + 1: read as a double</span>

    <span class="comment">// in a 64 bits integer environment</span>
    2147483648  <span class="comment">// INT_MAX + 1: read as a signed wxInt64</span>
    4294967295  <span class="comment">// UINT_MAX: read as a signed wxInt64</span>
    4294967296  <span class="comment">// UINT_MAX + 1: read as a signed wxInt64</span>
  }
</pre></div><p>
Also note that if a number is between INT64_MIN and INT64_MAX (or LONG_MIN and LONG_MAX, depending on the platform) it is always read as a signed integer regardless its original type. You can use a special writer's flag in order to force the wxJSON library to recognize unsigned JSON values written to JSON text. See <a class="el" href="wxjson_tutorial.html#wxjson_tutorial_style_unsigned">The wxJSONWRITER_RECOGNIZE_UNSIGNED flag</a> for more info.<h2><a class="anchor" name="wxjson_tutorial_write_doubles">
Writing doubles to JSON text output</a></h2>
There is an issue when you have to write double values to a decimal representation. You know that some fractional values such as, for example, 1/10 cannot be exactly represented in binary so when you write such values to a text representation there are rounding and/or truncating problems. The output you have depends on the format string used. This is an example using variuos format strings for printing the value of <b>1/10</b>. <div class="fragment"><pre class="fragment">  Format <span class="keywordtype">string</span>      Output
  -------------      ------
  %f                  0.100000
  %g                  0.1
  %.0g                0.1
  %.g:                0.1
  %.20g               0.10000000000000000555
  %.10g               0.1
</pre></div><p>
The wxJSON writer class has a function that allows you to set the format string for prinitng double values. The function is called <a class="el" href="classwxJSONWriter.html#5f77d5f0cfa2c781b3e5cbb11a636697" title="Set the format string for double values.">wxJSONWriter::SetDoubleFmtString</a> and sets the format string for the JSON writer object it is called for. If not specified, the default format string for the writer is:<p>
<div class="fragment"><pre class="fragment">  %.10g
</pre></div> which specifies a precision of 10 decimal digits and suppress trailing ZEROes.<h2><a class="anchor" name="wxjson_tutorial_memorybuff">
Storing binary memory buffers</a></h2>
You know that JSON is a text-based data interchange format but the word <em>data</em> refers especially to program variables and not other kind of data. JSON is not suitable for exchanging binary data such as audio, video, image or complex documents and it should not because it was not developed for that purpose. The goals of JSON are: simple, human-readable, fast and compact. On the other hand, there may be some particular situations in which a program should store and/or transmit small amount of binary data such as a small GIF image (for example a logo), a 1- or 2-seconds sound or a tiny memory buffer.<p>
In these situations, JSON is very limited: you cannot use JSON strings to store binary data because they are converted to UTF-8, the only possible solution is to use an array of numbers. For example, if we want to store a simple GIF image we can write something like the following: <div class="fragment"><pre class="fragment">    {
        <span class="stringliteral">"image"</span> :   {
            <span class="stringliteral">"type"</span>   : <span class="stringliteral">"gif"</span>,
            <span class="stringliteral">"width"</span>  : 160,
            <span class="stringliteral">"height"</span> : 160,
            <span class="stringliteral">"data"</span>   : [ 32, 160, 255, 47, 89, 47, 123, 85, ... ]
        }
    }
</pre></div> The above may be a solution but it consumes a lot of space because for every byte in the buffer we need 3-4 characters. Also, the program has to convert the buffer into an array of INTs when writing the JSON text and to convert it back when reading the stream. <b>wxJSON</b> introduces another JSON data type as an extension of the JSON syntax: the binary buffer data type. In order to maintain the text-based format, the binary buffer is encoded as a string of two hexadecimal digits for every byte and it is enclosed in single quotes. The above example will look like the following: <div class="fragment"><pre class="fragment">    {
        <span class="stringliteral">"image"</span> :   {
            <span class="stringliteral">"type"</span>   : <span class="stringliteral">"gif"</span>,
            <span class="stringliteral">"width"</span>  : 160,
            <span class="stringliteral">"height"</span> : 160,
            <span class="stringliteral">"data"</span>   : <span class="stringliteral">'20A0FF2F592F7B55...'</span>
        }
    }
</pre></div> The reader will store such a type in a <b>wxMemoryBuffer</b> object and the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class will have functions to return it and to construct and assign it: <div class="fragment"><pre class="fragment">    <span class="comment">// construct a binary buffer JSON value</span>
    <a class="code" href="classwxJSONValue.html#b297ae154241e77c41f61af52d5d653f" title="Constructors.">wxJSONValue</a>( <span class="keyword">const</span> wxMemoryBuffer&amp; mem );
    <a class="code" href="classwxJSONValue.html#b297ae154241e77c41f61af52d5d653f" title="Constructors.">wxJSONValue</a>( <span class="keyword">const</span> <span class="keywordtype">void</span>* mem, <span class="keywordtype">size_t</span> size );

    <span class="comment">// get the value as a memory buffer</span>
    <span class="keywordtype">bool</span>           wxJSONValue::IsMemBuffer();
    <span class="keywordtype">bool</span>           wxJSONValue::AsMemBuffer( wxMemoryBuffer&amp; buff );
    wxMemoryBuffer wxJSONValue::AsMemBuffer();

    <span class="comment">// assign to a wxJSONValue object a memory buffer</span>
    wxMemoryBuffer buff;
    wxJSONvalue v;
    v = buff;
</pre></div><p>
Because the <em>memory</em> <em>buffer</em> is not valid JSON text, you have to use the special <code>wxJSONREADER_MEMORYBUFF</code> flag in order to read such type otherwise an error is reported.<p>
By default, the <a class="el" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> will write a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> that contains a binary buffer type as an array of INTs thus producing valid JSON text output. If you want to write the special binary buffer type which will be recognized by the reader, you have to use the special <code>wxJSONWRITER_MEMORYBUFF</code> writer's flag. Note that other JSON implementations will fail to read such a text.<p>
Care has to be taken when dealing with <b>wxMemoryBuffer</b> objects: this is a fast helper class that uses reference counting when copying or assigning memory buffer objects but the class is not a <em>copy-on-write</em> structure: changes made to one object affects all other copies made from it. See the <b>wxWidgets'</b> documentation for more info about this class.<h2><a class="anchor" name="wxjson_tutorial_comment">
Using comment lines in wxJSON</a></h2>
Comments are not supported by the JSON syntax specifications but many JSON implementations do recognize and store comment lines in the JSON value objects. Starting by version 0.2, the wxJSON library do recognize and store C/C++ comment lines in the JSON input text and can also write comments to the JSON output text.<p>
Why should we use comments in JSON formatted text?<p>
There are several reasons: in an application's configuration file like the one we have seen in <a class="el" href="wxjson_tutorial.html#wxjson_tutorial_ex2">Example 2: a configuration file</a> comments are very usefull to help the user to understand the meaning of each configuration option.<p>
On the other hand, if a data structure is sent over a network connection, it is most likely that comments are not really needed but they may still be usefull for debugging purposes or for explaining the value, as in the following example:<p>
<div class="fragment"><pre class="fragment"> {
   <span class="stringliteral">"Person"</span> :  {
   {
     <span class="stringliteral">"Name"</span>    : <span class="stringliteral">"John Smith"</span>,
     <span class="stringliteral">"Height"</span>  : 190,   <span class="comment">// expressed in centimeters</span>
     <span class="stringliteral">"Birthday"</span> :  {
       <span class="stringliteral">"Year"</span>  : 1965,
       <span class="stringliteral">"Month"</span> : 8,
       <span class="stringliteral">"Day"</span>   : 18
     }
   }
 }
</pre></div><h3><a class="anchor" name="wxjson_tutorial_comment_funct">
Adding comments to JSON values</a></h3>
The <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class defines some functions for adding and retrieving comment lines in a JSON value. The function for adding comments is the <a class="el" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">wxJSONValue::AddComment()</a> function which takes two parameters:<p>
<ul>
<li>the string that has to be added as comment </li>
<li>the position of the comment line when the value is written to JSON text</li>
</ul>
The possible values for the <code>position</code> parameter are:<p>
<ul>
<li>wxJSONVALUE_COMMENT_BEFORE: the comment will be written before the value it refers to </li>
<li>wxJSONVALUE_COMMENT_AFTER: the comment will be written after the value it refers to </li>
<li>wxJSONVALUE_COMMENT_INLINE: the comment will be written on the same line as the value it refers to</li>
</ul>
Here is an example:<p>
<div class="fragment"><pre class="fragment">{
  <span class="comment">// comment before 'key-1'</span>
  <span class="stringliteral">"key-1"</span> : <span class="stringliteral">"value-1"</span>,
  <span class="stringliteral">"key-2"</span> : <span class="stringliteral">"value-2"</span>, <span class="comment">// comment inline 'key-2'</span>
  <span class="stringliteral">"key-3"</span> : <span class="stringliteral">"value-3"</span>
  <span class="comment">// comment after 'key-3'</span>
}
</pre></div><p>
To get the above output use the following code fragment:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> root;
  root[<span class="stringliteral">"key-1"</span>] = <span class="stringliteral">"value-1"</span>;
  root[<span class="stringliteral">"key-2"</span>] = <span class="stringliteral">"value-2"</span>;
  root[<span class="stringliteral">"key-3"</span>] = <span class="stringliteral">"value-3"</span>;

  root[<span class="stringliteral">"key-1"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment before"</span>, <a class="code" href="jsonval_8h.html#df764cbdea00d65edcd07bb9953ad2b740fcad8684e55757572c512883fe4a03">wxJSONVALUE_COMMENT_BEFORE</a> );
  root[<span class="stringliteral">"key-2"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment inline"</span>, <a class="code" href="jsonval_8h.html#df764cbdea00d65edcd07bb9953ad2b72ec7d0fa07e8bf91263abe3e3dd75583">wxJSONVALUE_COMMENT_INLINE</a> );
  root[<span class="stringliteral">"key-3"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment after"</span>, <a class="code" href="jsonval_8h.html#df764cbdea00d65edcd07bb9953ad2b738f9c851a81c2ffa53b547f65b7d7b40">wxJSONVALUE_COMMENT_AFTER</a> );
</pre></div><p>
You have to note that comment lines are kept in an array of strings in a data member of the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object: this means that you can add more than one comment line to a JSON value object but remember that there is only one data member for storing the position of all comment lines. In other words, the position at which the comment lines are written in the JSON output text in the same position as the one specified in the last call to the <a class="el" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">wxJSONValue::AddComment()</a> function.<p>
In order to prevent that the comment's position have to be set in the last call to the <code>AddComment()</code> function, you can specify the <code>wxJSONVALUE_COMMENT_DEFAULT</code> constant as the position parameter. This constant causes the function to not modify the actual position value. If you use this constant in the first call to the <code>AddComment()</code> function, it is interpreted as <code>wxJSONVALUE_COMMENT_BEFORE</code>. Below you find an example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> root;
  root.<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment for root (line 1)"</span>, <a class="code" href="jsonval_8h.html#df764cbdea00d65edcd07bb9953ad2b740fcad8684e55757572c512883fe4a03">wxJSONVALUE_COMMENT_BEFORE</a> );

  <span class="comment">// no need to specify the comment position in subsequent calls to AddComment()</span>
  <span class="comment">// the old position is not modified</span>
  root.<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment for root (line 2)"</span> );

  <span class="comment">// set the value for 'key-1'</span>
  root[<span class="stringliteral">"key-1"</span>] = <span class="stringliteral">"value1"</span>;

  <span class="comment">// now we add a comment line for 'key-1'. We do not specify the comment</span>
  <span class="comment">// position so it defaults to wxJSONVALUE_COMMENT_DEFAULT which cause</span>
  <span class="comment">// the AddCommnen() function to maintan the old position.</span>
  <span class="comment">// As the comment position was never set before, the wxJSONVALUE_COMMENT_BEFORE</span>
  <span class="comment">// will be set</span>
  root[<span class="stringliteral">"key-1"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment before key-1"</span> );

  <span class="comment">// set the value of 'key-4' an an empty object.</span>
  <span class="comment">// note that we cannot use the default wxJSONValue constructor to get an</span>
  <span class="comment">// empty object type: the default ctor constructs a NULL value object.</span>
  root[<span class="stringliteral">"key-4"</span>] = <a class="code" href="classwxJSONValue.html#b297ae154241e77c41f61af52d5d653f" title="Constructors.">wxJSONValue</a>( <a class="code" href="jsonval_8h.html#33ce9d3ffb9313f4a2360157aeb975926e5fc37d2c3526b8f6380d58a1b1029b">wxJSONTYPE_OBJECT</a> );

  <span class="comment">// now we add an inline comment to 'key-4'</span>
  root[<span class="stringliteral">"key-4"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// comment inline key-4"</span>,
                     <a class="code" href="jsonval_8h.html#df764cbdea00d65edcd07bb9953ad2b72ec7d0fa07e8bf91263abe3e3dd75583">wxJSONVALUE_COMMENT_INLINE</a> );

  <span class="comment">// now we write the JSON 'root' value to a JSON formatted string</span>
  <span class="comment">// object. Note that we have to specify some flags in the wxJSONWriter</span>
  <span class="comment">// constructor</span>
  <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer( <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5a67859cf6380120c9bec21de50adf446">wxJSONWRITER_STYLED</a> | <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b51c292ae7207bbe36ef0e805f942171a2">wxJSONWRITER_WRITE_COMMENTS</a> );
  wxString  jsonText;
  writer.<a class="code" href="classwxJSONWriter.html#2cebc74d641090c6946dac631b782f2e" title="Write the JSONvalue object to a JSON text.">Write</a>( root, jsonText );
</pre></div><p>
Below is the output text:<p>
<div class="fragment"><pre class="fragment"> <span class="comment">// comment for root (line 1)</span>
 <span class="comment">// comment for root (line 2)</span>
 {
   <span class="comment">// comment before 'key2'</span>
   <span class="stringliteral">"key-1"</span> : <span class="stringliteral">"value1"</span>,
   <span class="stringliteral">"key-4"</span> : {   <span class="comment">// comment inline key-4</span>
   }
 }
</pre></div><h3><a class="anchor" name="wxjson_tutorial_comment_inline">
Adding inline comments</a></h3>
You should be carefull when adding inline comments. Comment lines are stored in an array of string, thus allowing to have more than one line of comments. This is good for comments that apear <em>before</em> or <em>after</em> the value they refer to but for <em>inline</em> comments, the output is not easy to read. Look at the following example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> root;
  root[<span class="stringliteral">"key-1"</span>] = <span class="stringliteral">"value1"</span>;
  root[<span class="stringliteral">"key-1"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">" // comment inline (1)"</span>, <a class="code" href="jsonval_8h.html#df764cbdea00d65edcd07bb9953ad2b72ec7d0fa07e8bf91263abe3e3dd75583">wxJSONVALUE_COMMENT_INLINE</a> );
  root[<span class="stringliteral">"key-1"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">" // comment inline (2)"</span> );
  root[<span class="stringliteral">"key-1"</span>].<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">" // comment inline (3)"</span> );

  <span class="comment">// this is the JSON formatted output:</span>

{
   <span class="stringliteral">"key-1"</span> : <span class="stringliteral">"value1"</span>, <span class="comment">// comment inline (1)</span>
<span class="comment">// comment inline (2)</span>
<span class="comment">// comment inline (3)</span>
}
</pre></div><p>
Note that only the first line is really printed <b>inline</b>. The other two lines are printed after the value they refer to and without indentation: this is not very readable. For this reason, you should use <b>inline</b> comments only when you have only one line of comments. If you need more than one line of comment use the <b>before</b> or the <b>after</b> comment's position.<h3><a class="anchor" name="wxjson_tutorial_comment_syntax">
Syntax checks for comment lines</a></h3>
The <a class="el" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">wxJSONValue::AddComment()</a> function checks that the string that you are adding as a comment to the JSONvalue object is a correct C/C++ comment. In other words, if you want to add a C++ comment string, the string passed as a parameter to the <a class="el" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">wxJSONValue::AddComment()</a> function must start with two slash characters and must end with a LF. If the LF character is missing, the function adds it for you. The following code fragment shows some examples:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 10 );
  v1.<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// A C++ comment line\n"</span> );     <span class="comment">// this is OK</span>

  v1.<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// Another C++ comment line"</span> ); <span class="comment">// this is OK</span>

  v1.<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"/*  A C-style comment */"</span>);     <span class="comment">// OK</span>

  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2( 20 );
  v2.AddComment( <span class="stringliteral">"A C++ comment line\n"</span> );   <span class="comment">// Error: does not start with '//'</span>

  v2.AddComment( <span class="stringliteral">"/ A C++ comment line\n"</span> ); <span class="comment">// Error: does not start with '//'</span>

  v2.AddComment( <span class="stringliteral">"/*** comment **"</span> );        <span class="comment">// Error: the close-comment is missing</span>

  <span class="comment">// the following is OK: new-line characters may follow</span>
  <span class="comment">// the end-comment characters of a C-style comment</span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v3( 30 );
  v2.AddComment( <span class="stringliteral">"/*** C comment ***/\n\n\n"</span> );
</pre></div><p>
Note that the function cannot trap all possible errors because the checks that are done by the function are very simple:<p>
<ul>
<li>for C++ comments checks that the string starts with two slash characters and ends with a LF char: the LF char is automatically added if it is missing </li>
<li>for C-style comments check that the string start with the slash-asterisk character couple and ends with the asterisk-slash caracters (trailing LF chars are permitted)</li>
</ul>
Note that the following examples are considered OK by the function but if you add those strings to some values and write them to a JSON text stream you end up with a incorrect JSON text.<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// the following is not correct: the AddComment() function only</span>
  <span class="comment">// appends the final LF char </span>
  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 10 );
  v1.<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// Line 1\nLine2"</span> );

  <span class="comment">// this is the JSON output (it is not valid JSON text)</span>
  ...
  <span class="comment">// Line 1</span>
  Line 2
  10
  ...
</pre></div><p>
You would have to write:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v1( 10 );
  v1.<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// Line 1"</span> );
  v1.<a class="code" href="classwxJSONValue.html#2178b6fa0ca8bb4d7b29bd4251f09b35" title="Add a comment to this JSON value object.">AddComment</a>( <span class="stringliteral">"// Line 2"</span> );
</pre></div><p>
Nested C-style comments are not handled correctly by the wxJSON parser:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v2( 20 );
  v2.AddComment( <span class="stringliteral">"/* comment1 /* comment2 */ */"</span> );

  <span class="comment">// this is the JSON text output:</span>
  ...
  <span class="comment">/* comment1 /* comment2 */</span> */
  20
  ...
</pre></div><p>
The parser will report an error when it reads the last close-comment characters because when a C-style comment starts, all characters until the first close-comment chars are ignored by the parser.<h3><a class="anchor" name="wxjson_tutorial_comment_parser">
Reading comment lines from JSON text</a></h3>
As already written above, comment lines are a wxJSON extension to the JSON format specification. Comments may be directly added to <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> objects using memberfunctions or they can be stored in the values when a JSON formatted text input is read by the parser. Note that by default the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> class recognizes C/C++ comments in the input text but simply ignores them: if you want to store the comments in the value they refer to you have to pass some flags to the parser's constructor:<p>
<div class="fragment"><pre class="fragment">  <span class="comment">// this ctor is error tolerant and stores comments</span>
  <a class="code" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> reader1( <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b3f5d37c235197f1a80f51bf2ba124401">wxJSONREADER_TOLERANT</a> | <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b36a67602c6837daa0319dacb9e121af7">wxJSONREADER_STORE_COMMENTS</a> );

  <span class="comment">// this ctor is not error tolerant: wxJSON extensions are off</span>
  <span class="comment">// the parser does not recognize comments: they are reported as errors</span>
  <a class="code" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> reader2( <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b9ed2f2f3e60fff7c2e00340ba8a76d2f">wxJSONREADER_STRICT</a> );

  <span class="comment">// this ctor is error tolerant but does not store comments</span>
  <a class="code" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> reader3;

  <span class="comment">// this ctor recognizes all wxJSON extensions except the</span>
  <span class="comment">// 'multiline string' feature which is reported as an error</span>
  <span class="comment">// the parser also stores comments</span>
  <a class="code" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> reader1( <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55bbd5317f7470efedabb26aab3195a9ab0">wxJSONREADER_ALLOW_COMMENTS</a>
                      | <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55bc1ed8fd05a7d24536a537b6e3159eb17">wxJSONREADER_CASE</a>
                      | <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b366a982a77ff59c21d68a784e2fd7627">wxJSONREADER_MISSING</a>
                      | <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b36a67602c6837daa0319dacb9e121af7">wxJSONREADER_STORE_COMMENTS</a>  );

  <span class="comment">// parser is tolerant and stores comments but comments apear AFTER</span>
  <span class="comment">// the value they refer to</span>
  <a class="code" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> reader1( <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b3f5d37c235197f1a80f51bf2ba124401">wxJSONREADER_TOLERANT</a> | <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b36a67602c6837daa0319dacb9e121af7">wxJSONREADER_STORE_COMMENTS</a> );
                      | <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b9d84beea14df0fdc9ba64e8c03332431">wxJSONREADER_COMMENTS_AFTER</a>  );
</pre></div><p>
See the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> class's description for more informations about the wxJSON parser's extensions. Also note that the constructor's flags related to comments are only meaningfull if the main flags are also specified. In other words, the <code>wxJSONREADER_STORE_COMMENTS</code> flag is only meaningfull if <code>wxJSONREADER_ALLOW_COMMENTS</code> is also set (or the <code>wxJSONREADER_TOLERANT</code> constant which includes it). Also, the <code>wxJSONREADER_COMMENTS_AFTER</code> is only meaningfull if <code>wxJSONREADER_STORE_COMMENTS</code> is also set: if comments are not stored, there is no need for the parser to know the position of the comments with respect to the value.<p>
Below you find a JSON text with many comment lines and the description of which value the comments refer to. The parser is constructed with the <code>wxJSONREADER_STORE_COMMENT</code> flag set, thus the parser assumes that comments apear <b>before</b> the value they refer to.<p>
<div class="fragment"><pre class="fragment"><span class="comment">// comment for root (line 1)</span>
<span class="comment">// comment for root (line 2)</span>
{
   <span class="stringliteral">"key-1"</span> : <span class="stringliteral">"value1"</span>,

   <span class="comment">// comment before 'key2'</span>
   <span class="stringliteral">"key-2"</span> : <span class="stringliteral">"value2"</span>,
   <span class="comment">// comment before 'key3' (1)</span>
   <span class="comment">// comment before 'key3' (2)</span>

   <span class="stringliteral">"key-3"</span> : {
      <span class="stringliteral">"key3-1"</span> : <span class="stringliteral">"value3-1"</span>,

      <span class="comment">// comment before key3-2</span>
      <span class="stringliteral">"key3-2"</span> : <span class="stringliteral">"value3-2"</span>
   },

   <span class="stringliteral">"key-4"</span> : {   <span class="comment">// comment inline key4</span>
      <span class="comment">// this comment does not refer to anything</span>
   }

   <span class="stringliteral">"key-5"</span> : [ <span class="comment">// comment inline key5</span>

      <span class="comment">// comment before item 5-1</span>
      <span class="stringliteral">"item5-1"</span>,
      <span class="stringliteral">"item5-2"</span>, <span class="comment">// comment inline 5-2</span>
      <span class="stringliteral">"item5-3"</span>  <span class="comment">// comment inline 5-3</span>

      <span class="comment">// this comment does not refer to anything</span>
   ],

   <span class="stringliteral">"key-6"</span>
      :        <span class="comment">// comment inline key-6</span>
        <span class="stringliteral">"value"</span>,

   <span class="stringliteral">"key-7"</span> : {
      <span class="stringliteral">"key-7-1"</span> : <span class="stringliteral">"value-7-1"</span>
   },        <span class="comment">// comment inline key-7</span>

   <span class="stringliteral">"key-8"</span>     <span class="comment">// comment inline key-8(1)</span>
      :        <span class="comment">// comment inline key-8(2)</span>
      <span class="stringliteral">"value"</span>, <span class="comment">// comment inline key-8(3)</span>

   <span class="stringliteral">"key-9"</span> : {
      <span class="stringliteral">"key9-1"</span> : 91,
      <span class="stringliteral">"key9-2"</span> : 92
   }


   <span class="stringliteral">"key-10"</span> : [
   ]            <span class="comment">// comment inline key-10</span>

   <span class="comment">// this comment does not refer to anything</span>
}
<span class="comment">// this comment does not refer to anything</span>
<span class="comment">// if comments apear before the value</span>

This non-JSON text is ignored by the parser because
it apears after the top-level close-<span class="keywordtype">object</span> character
</pre></div><h2><a class="anchor" name="wxjson_tutorial_unicode">
Unicode support in wxJSON</a></h2>
The JSON syntax states that JSON string values are stored in Unicode format and the encoding of a JSON text is by default UTF-8; UCS-2 (AKA UTF-16) and UCS-4 (AKA UTF-32) are also allowed (but, in fact, not much used). The wxJSON library follows this rules but because wxJSON (and wxWidgets itself) may be compiled in two different modes (by now) we have to distinguish two situations:<p>
<ul>
<li>Unicode builds </li>
<li>ANSI builds</li>
</ul>
Also note that JSON text may be written to / read from two different kind of objects: a <b>wxString</b> or a <b>stream</b>. These two objects are very different in the way they encode strings.<h3><a class="anchor" name="wxjson_tutorial_unicode_uni">
Unicode support: Unicode builds</a></h3>
When <b>wxJSON</b> is built in Unicode mode, there is no problem at all. JSON text is read from / written to a <b>wxString</b> object or a <em>stream</em> in the same way because:<p>
<ul>
<li>the reader converts the JSON text input from a string object to a temporary UTF-8 memory buffer stream. </li>
<li>the writer always writes to a stream object in UTF-8 format. If output has to go to a string object, the writer constructs a temporary memory buffer stream to which output is written. The temporary stream is finally converted to a <b>wxString</b> object</li>
</ul>
The conversion of <b>wxString</b> objects to temporary UTF-8 streams is convenient for several reasons:<p>
<ul>
<li>in Unicode builds the actual character encoding of strings depends on the platform and wxWidgets version. It may be UTF-16, UTF-32, UTF-8: these differences complicate the processing of characters</li>
</ul>
<ul>
<li>UTF-8 streams are <em>byte-oriented</em>: JSON special characters and literal are in the US-ASCII charset and encoded as one UTF-8 code unit; we do not have to deal with <code>wchar_t</code> and <code>wxUniChar</code>. The processing of characters is as <b>char</b>.</li>
</ul>
<ul>
<li>reading a UTF-8 JSON string is simple: when a double-quote char is encontered just copy all bytes until the next unescaped double-quote in a UTF-8 memory buffer and convert the whole buffer to <b>wxString:</b> process only escaped characters.</li>
</ul>
<ul>
<li>writing JSON string values is simple: just convert the string to UTF-8 and append to the stream: process characters that have to be escaped; they all belong to the US-ASCII charset.</li>
</ul>
When using Unicode builds you can directly hardcode JSON values in all character sets as, for example:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>  value;
  value[_T(<span class="stringliteral">"us-ascii"</span>)] = _T(<span class="stringliteral">""</span>abcABC<span class="stringliteral">");</span>
<span class="stringliteral">  value[_T("</span>latin1<span class="stringliteral">")]   = _T("</span><span class="stringliteral">");</span>
<span class="stringliteral">  value[_T("</span>greek<span class="stringliteral">")]    = _T("</span><span class="stringliteral">");</span>
<span class="stringliteral">  value[_T("</span>cyrillic<span class="stringliteral">")] = _T("</span><span class="stringliteral">");</span>
<span class="stringliteral"></span>
<span class="stringliteral">  wxMemoryOutputStream os;</span>
<span class="stringliteral">  wxJSONWriter writer;</span>
<span class="stringliteral">  writer.Write( value, os );</span>
</pre></div><p>
The above code fragment contains characters from various european languages which are incompatible in a locale dependant environment. The output memory stream contains a UTF-8 encoded text. <b>WARNING:</b> the possibility to directly hardcode Unicode strings such as the one I wrote before depends on your editor which has to be able to save the source file in a format that support Unicode (for example, UTF-8). Also, your compiler must be able to read and compile UTF-8 sources. This is the case of GCC on my linux machine but when I tried to run a test on windows using Borland BCC 5.5 the output was not as expected.<p>
Note that I/O from / to stream objects is always encoded in UTF-8 format and no other format is supported by this library. If you want to encode the JSON text to a different format you can use the <b>wxMBConv</b> -derived classes to do the job. For example, if you want to encode the output JSON text in UCS-4, you may use the following code:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>  value;
  value[_T(<span class="stringliteral">"us-ascii"</span>)] = _T(<span class="stringliteral">""</span>abcABC<span class="stringliteral">");</span>
<span class="stringliteral">  value[_T("</span>latin1<span class="stringliteral">")]   = _T("</span><span class="stringliteral">");</span>
<span class="stringliteral">  value[_T("</span>greek<span class="stringliteral">")]    = _T("</span><span class="stringliteral">");</span>
<span class="stringliteral">  value[_T("</span>cyrillic<span class="stringliteral">")] = _T("</span><span class="stringliteral">");</span>
<span class="stringliteral"></span>
<span class="stringliteral">  wxMemoryOutputStream os;</span>
<span class="stringliteral">  wxJSONWriter writer;</span>
<span class="stringliteral">  writer.Write( value, os );</span>
<span class="stringliteral">  </span>
<span class="stringliteral">  // get the address of the UTF-8 buffer</span>
<span class="stringliteral">  wxStreamBuffer* osBuff = os.GetOutputStreamBuffer();</span>
<span class="stringliteral">  void* buffStart = osBuff-&gt;GetBufferStart();</span>
<span class="stringliteral"></span>
<span class="stringliteral">  // first convert the UTF-8 stream to wide-chars</span>
<span class="stringliteral">  wchar_t *wcBuffer;</span>
<span class="stringliteral">  size_t len = wxMBConvUTF8.ToWChar(</span>
<span class="stringliteral">                        0,           // wchar_t* the destination buffer</span>
<span class="stringliteral">                        0,           // size_t: the destination length</span>
<span class="stringliteral">                        buffStart,   // char*: the source buffer</span>
<span class="stringliteral">                        os.GetLength());   // size_t: the source length</span>
<span class="stringliteral"></span>
<span class="stringliteral">  // the conversion should never fail in unicode builds</span>
<span class="stringliteral">  wxASSERT( len != wxCONV_FAILED);</span>
<span class="stringliteral">  </span>
<span class="stringliteral">  // allocate the destination buffer and perform conversion</span>
<span class="stringliteral">  wcBuffer = new wchar_t[len + 1];</span>
<span class="stringliteral">  wxMBConvUTF8.ToWChar( wcBuffer,</span>
<span class="stringliteral">                        len + 1,</span>
<span class="stringliteral">                        buffStart,</span>
<span class="stringliteral">                        os.GetLength());</span>
<span class="stringliteral"></span>
<span class="stringliteral">  // now convert the wide character buffer to UCS-4</span>
<span class="stringliteral">  char* ucs4Buffer;</span>
<span class="stringliteral">  ucs4Len = wxMBConvUTF32.FromWChar(</span>
<span class="stringliteral">                        0,           // char*: the destination buffer</span>
<span class="stringliteral">                        0,           // size_t: the destination length</span>
<span class="stringliteral">                        buffStart,   // w_chart*: the source buffer</span>
<span class="stringliteral">                        len);        // size_t: the source length</span>
<span class="stringliteral">  </span>
<span class="stringliteral">  // the conversion should never fail in unicode builds</span>
<span class="stringliteral">  wxASSERT( ucs4Len != wxCONV_FAILED);</span>
<span class="stringliteral"></span>
<span class="stringliteral">  // allocate the destination buffer and perform conversion</span>
<span class="stringliteral">  ucs4Buffer = new char[ucs4Len + 1];</span>
<span class="stringliteral">  wxMBConvUTF8.FromWChar( wcBuffer,</span>
<span class="stringliteral">                            ucs4Len + 1,</span>
<span class="stringliteral">                            wcBuffer,</span>
<span class="stringliteral">                            len);</span>
</pre></div><p>
We have a UCS-4 buffer ready to be written to a file or trasmitted across the network. Note that UCS-4 do have endianness (byte order) issues so you should prepend a BOM (Byte Order Mark) to the stream. To know more about this topic read the wxMBConvUTF32 class's docs.<p>
Note that the above code fragment should work fine because the selected encoding format has full support for Unicode characters. On the other hand, you <em>cannot</em> convert the output stream to whatever format you want; in other words, you cannot convert it to a locale dependent charset because the string contains characters from different languages which are encoded in different locale dependent charsets (by the way, the charsets that have to be used are ISO-8859-1 for Latin1, ISO-8859-7 for greek and ISO-8859-5 for cyrillic). For example, the following code does not work:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>  value;
  ...
  
  <span class="comment">// after converting to wide char we want now to convert to Latin-1</span>
  wxCSConv latin1Conv( _T(<span class="stringliteral">"ISO-8859-1"</span>));
  
  <span class="comment">// compute the length of the needed buffer</span>
  <span class="comment">// what we get is the wxCONV_FAILED error code</span>
  <span class="keywordtype">size_t</span> targetLen = latin1Conv.FromWChar(
                        0,           <span class="comment">// char*: the destination buffer</span>
                        0,           <span class="comment">// size_t: the destination length</span>
                        buffStart,   <span class="comment">// w_chart*: the source buffer</span>
                        len);        <span class="comment">// size_t: the source length</span>
</pre></div><p>
The better solution, however, is to get a UTF-8 encoded buffer which is compatible with all other JSON implementations. To have a UTF-8 encoded JSON text just use a stream as output. You can also use a <b>wxString</b> object as JSON text output and then convert it to UTF-8.<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a>  value;
  wxString     jsonText;
  <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer;

  <span class="comment">// write to a string object</span>
  writer.<a class="code" href="classwxJSONWriter.html#2cebc74d641090c6946dac631b782f2e" title="Write the JSONvalue object to a JSON text.">Write</a>( value, jsonText );

  <span class="comment">// convert to UTF-8</span>
  wxCharBuffer buffer = jsonText.ToUTF8();
</pre></div><p>
However, you have to note that the output to a <b>wxString</b> object is obtained by writing to a UTF-8 temporary memory stream and converting it to <b>wxString</b> so it is very inefficient to use a string output object to get a UTF-8 encoded text (just use a stream for the output).<p>
Is there a mean to exchange JSON data from a Unicode mode application to an ANSI one (and viceversa)? The answer is: YES, but there are several limitations.<h3><a class="anchor" name="wxjson_tutorial_unicode_ansi">
Unicode support: ANSI builds</a></h3>
When <b>wxJSON</b> is compiled in ANSI mode both the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> and the <a class="el" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> give you a limited Unicode support but remember that the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> class <b>cannot</b> store wide char string values because the <b>wxString</b> class only contains one-byte character strings and the actual characters represented are locale dependent. We have to distinguish the following situations:<p>
<ul>
<li>writing to string objects </li>
<li>writing to stream objects </li>
<li>reading from string objects </li>
<li>reading from stream objects</li>
</ul>
<h4><a class="anchor" name="wxjson_tutorial_unicode_ansi1">
ANSI builds: writing to string objects</a></h4>
This operation does not have issues. Unlike in Unicode builds, the writer does not use a temporary UTF-8 stream to store the JSON text output. A stream is used for the actual output but it is not encoded in UTF-8: the temporary stream just contains ANSI characters which are just copied to the <b>wxString</b> output object.<h4><a class="anchor" name="wxjson_tutorial_unicode_ansi2">
ANSI builds: writing to stream objects</a></h4>
When output is sent to a stream, the default behaviour of the <b>wxJSON</b> library is to use a UTF-8 encoded text. This permits the JSON text to be sent to other JSON implementations and also to wxWidgets applications (that use wxJSON) built in Unicode mode.<p>
Note that if the JSON text is to be read from the same ANSI application, you can suppress UTF-8 encoding by specifying the<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5887ce7589fbc9ff78c81bd9ad7615bc1">wxJSONWRITER_NOUTF8_STREAM</a>
</pre></div><p>
flag in the wxJSONWriter's constructor. This flag suppress UTF-8 encoding in the outputted JSON stream; thus, it will constain ANSI characters. Note that the JSON text produced in this way is not compatible with Unicode mode applications and is not valid JSON text so that other JSON implementations will fail to read it. Also note that the same ANSI application that wrote such ANSI text may be used in a different locale using a different character set: in this case all characters outside the US-ASCII charset (0x80..0xFF) will be misunderstood.<p>
There is only an exception to this: <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> strings that contain UTF-8 code units that have been read from the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> using a specific reader's flag. To know more about this read the subsection related to reading from streams.<h4><a class="anchor" name="wxjson_tutorial_unicode_ansi3">
ANSI builds: reading from string objects</a></h4>
This operation does not have issues. Unlike in Unicode builds, the reader does not use a temporary UTF-8 stream to read the JSON text input. A stream is used for the actual input operation but it is not encoded in UTF-8: the temporary stream just contains ANSI characters which are just copied to a <b>wxString</b> when the reader reads a JSON string value.<h4><a class="anchor" name="wxjson_tutorial_unicode_ansi4">
ANSI builds: reading from stream objects</a></h4>
When input is from a stream, the default behaviour of the <b>wxJSON</b> library is to read UTF-8 encoded text. When a JSON string is encontered, the reader stores all UTF-8 code-units in a temporary memory buffer. The reader tries to convert the temporary buffer to a <b>wxString</b> object using the <b>wxString::FromUTF8()</b> static function. If the conversion succeeds the string is stored in the <b>wxString</b> object but the conversion may fail because the UTF-8 input text may contain characters that cannot be represented in the current locale. If the UTF-8 input text cannot be converted in a <b>wxString</b> object then a char-by-char conversion takes place: every unrepresentable character is stored in the <b>wxString</b> object as a <em>unicode</em> <em>escape</em> <em>sequence</em>.<p>
For example, the following UTF-8 file:<p>
<div class="fragment"><pre class="fragment">{
  <span class="stringliteral">"us-ascii"</span> : <span class="stringliteral">"abcABC"</span>,
  <span class="stringliteral">"latin1"</span>   : <span class="stringliteral">""</span>,
  <span class="stringliteral">"greek"</span>    : <span class="stringliteral">""</span>,
  <span class="stringliteral">"cyrillic"</span> : <span class="stringliteral">""</span>
}
</pre></div><p>
is read by an ANSI application which is localized in West Europa thus using the ISO-8859-1 (Latin-1) character set. The last two string values cannot be represented in ISO-8859-1 charset so the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> class stores unicode sequences. The following is the representation of the root <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object:<p>
<div class="fragment"><pre class="fragment">{
  <span class="stringliteral">"us-ascii"</span> : <span class="stringliteral">"abcABC"</span>,
  <span class="stringliteral">"latin1"</span>   : <span class="stringliteral">""</span>,
  <span class="stringliteral">"greek"</span>    : <span class="stringliteral">"\u03B1\u03B2\u03B3\u03B4"</span>,
  <span class="stringliteral">"cyrillic"</span> : <span class="stringliteral">"\u0424\u0425\u0426\u0427"</span>
}
</pre></div><p>
In this way the original meaning of the UTF-8 JSON text is preserved and it may also be rewritten to a UTF-8 stream but there are some issues:<p>
<ul>
<li>writing to a UTF-8 stream does not revert the sequences as UTF-8. The unicode escaped sequences are written as they apear </li>
<li>the JSON syntax states that only control characters are encoded in such escaped sequences: the output is not valid JSON text </li>
<li>although the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> is capable to handle such sequences and convert them to Unicode characters other JSON implementations may fail to read them and, probably, they treat the sequences as errors </li>
<li>the reader is only capable to handle 4-hex-digits sequences so only Unicode code points in the first plane (the so-called BMP) can be represented.</li>
</ul>
Someone may also think: "who cares about characters that cannot be represented in the actual locale charset? Just copy the UTF-8 text input in the wxString object".<p>
This is simple, fast, convenient! Also, we can use the <code>wxJSONWRITER_NOUTF8_STREAM</code> flag to rewrite the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> objects as they apear, without any conversion, thus producing the same, valid UTF-8 text as we read it!!<p>
For this reason, the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> class can be constructed with a special reader's flag, the<p>
<div class="fragment"><pre class="fragment">    <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b61cd42579e05db62b2a3db6f410a5e7a">wxJSONREADER_NOUTF8_STREAM</a>
</pre></div><p>
which forces the reader to not try any conversion from UTF-8 streams and just store the UTF-8 code-units in the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object.<p>
<b>WARNING:</b> please note that both the writer's and reader's <code>_NOUTF8_STREAM</code> flag only have effect in ANSI builds. In Unicode builds UTF-8 streams are <b>always</b> converted to the native encoding of <b>wxString</b> objects. You cannot use the NOUTF8_STREAM flag to directly store UTF-8 code units in a <b>wxString</b> object in Unicode mode.<h3><a class="anchor" name="wxjson_tutorial_unicode_bom">
The Byte Order Mark (BOM)</a></h3>
A few <b>wxJSON</b> users wrote to me asking why the UTF-8 stream (or file) does not have a BOM such as the one that we can find at the beginning of text documents saved as UTF-8 on Windows platform.<p>
The answer is taken from the Wikipedia (<a href="http://en.wikipedia.org/wiki/Byte_Order_Mark">http://en.wikipedia.org/wiki/Byte_Order_Mark</a>):<p>
<div class="fragment"><pre class="fragment">While UTF-8 does not have byte order issues, a BOM encoded in UTF-8 may
nonetheless be encountered. A UTF-8 BOM is explicitly allowed by the Unicode
standard, but is not recommended, as it only identifies a file as UTF-8 and
does not state anything about byte order. Many Windows programs (including
Windows Notepad) <span class="keyword">add</span> BOM<span class="stringliteral">'s to UTF-8 files by default.</span>
</pre></div><p>
As UTF-8 is the only recognized encoding of a stream we do not need a UTF-8 signature at the beginning of the stream:<p>
<ul>
<li>the <a class="el" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> does not prepend a BOM to a UTF-8 streams. </li>
<li>the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> does not expect a BOM when it reads a UTF-8 stream; if a BOM is present, it is simply ignored.</li>
</ul>
<h2><a class="anchor" name="wxjson_tutorial_style">
The wxJSON writer's styles</a></h2>
The JSON text generator - <a class="el" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> class - normally generates strict JSON text which is very hard to read by humans. In order to facilitate this job, mainly for debugging purposes, the writer can write <em>styled</em> text using some flags in the writer's constructor. Note that some flags depend on other ones in order to take effect. The following are some examples of the text output using various flags.<h3><a class="anchor" name="wxjson_tutorial_style_styled">
The wxJSONWRITER_STYLED flag</a></h3>
This flag cause the wxJSON writer to produce human-readable text output. Every value is separated from the previous one by a line-feed character and sub-objects are indented by a three space characters. Here is an example:<p>
<div class="fragment"><pre class="fragment">{
   <span class="stringliteral">"key1"</span> : <span class="stringliteral">"value1"</span>,
   <span class="stringliteral">"key2"</span> : {
      <span class="stringliteral">"key2-1"</span> : 12
   }
}
</pre></div><h3><a class="anchor" name="wxjson_tutorial_style_tab">
The wxJSONWRITER_TAB_INDENT flag</a></h3>
This is the same as above but the indentation is done using TABs and not the space character.This produces a more compact text and it is preferable than the normal styled output. This flag only has effect if wxJSONWRITER_STYLED is also set. Example:<p>
<div class="fragment"><pre class="fragment">{
    <span class="stringliteral">"key1"</span> : <span class="stringliteral">"value1"</span>,
    <span class="stringliteral">"key2"</span> : {
        <span class="stringliteral">"key2-1"</span> : 12
    }
}
</pre></div><h3><a class="anchor" name="wxjson_tutorial_style_none">
The wxJSONWRITER_NONE flag</a></h3>
This flag cause the writer to only produce strict JSON text without any formatting: LF characters between values are not written and no indentation is performed. Also, no comment strings are written. This is a good choice if the text has to be sent over a network connection because it produces the most compact text. Example:<p>
<div class="fragment"><pre class="fragment">{<span class="stringliteral">"key1"</span> : <span class="stringliteral">"value1"</span>,<span class="stringliteral">"key2"</span> : { <span class="stringliteral">"key2-1"</span> : 12 }}
</pre></div><p>
Note that the JSON text output is a bit different from that of 0.x versions because in the prevoious versions this style adds LF characters between values. Linefeeds are not added in the new 1.0 version of wxJSON. The JSON output text is syntactically equal in both implementations: they only differ for the LF character. If you rely on the old text output, you can have the same results by specifying the following flags: <div class="fragment"><pre class="fragment">  <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5a67859cf6380120c9bec21de50adf446">wxJSONWRITER_STYLED</a> | <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5647e3070e9e5acee9ce89d0488904a6f">wxJSONWRITER_NO_INDENTATION</a>
</pre></div><p>
which actually produce the same result as the old wxJSONWRITER_NONE flag; adds LF between values but suppress indentation.<h3><a class="anchor" name="wxjson_tutorial_style_nolf">
The wxJSONWRITER_NO_LINEFEEDS flag</a></h3>
<h3><a class="anchor" name="wxjson_tutorial_style_notab">
The wxJSONWRITER_NO_INDENTATION flag</a></h3>
These two flags are only meaningfull if the wxJSONWRITER_STYLED was specified and cause the writer to not add line-feed characters between values and / or to remove the indentation. Because wxJSONWRITER_STYLED adds LF and performs indentation, specifying all the three flags is equal as wxJSONWRITER_NONE:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer( <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5a67859cf6380120c9bec21de50adf446">wxJSONWRITER_STYLED</a> | 
            <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5647e3070e9e5acee9ce89d0488904a6f">wxJSONWRITER_NO_INDENTATION</a> |
            <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b588a411c27c2933477b57fbdd4bc823a9">wxJSONWRITER_NO_LINEFEEDS</a> );

  <span class="comment">// is the same as:</span>
  <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer( <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5a8b4e7c384d29852bb79bcabf4ad2eba">wxJSONWRITER_NONE</a> );
</pre></div><p>
If the <b>styled</b> flag is not specfified, these two flags are useless and has no effect: it is not an error to specify them because the writer simply ignores them. The following is a text output of a value written using the wxJSONWRITER_STYLED and wxJSONWRITER_NO_LINEFEEDS flags: as you can see, LF are not printed but indentation is performed.<p>
<div class="fragment"><pre class="fragment">{   <span class="stringliteral">"key1"</span> : <span class="stringliteral">"value1"</span>,   <span class="stringliteral">"key2"</span> : {      <span class="stringliteral">"key2-1"</span> : 12      }   }
</pre></div><p>
Also note that the LF characters are only suppressed between values and not for comments. If you include C++ comments in the JSON text output, they <b>need</b> LF characters in order to mark the end of the comment. Note that C-style comments do not need a LF character to mark their end so this flag cause the LF character to be suppressed between values. LF characters that are contained in the C-style comment are not suppressed.<p>
Example using the wxJSONWRITER_NO_LINEFEEDS and wxJSONWRITER_WRITE_COMMENTS:<p>
<div class="fragment"><pre class="fragment">{   <span class="stringliteral">"key1"</span> : <span class="stringliteral">"value1"</span>, <span class="comment">// C++ comment cause the LF char to be written</span>
      <span class="stringliteral">"key2"</span> : {      <span class="stringliteral">"key2-1"</span> : 12   }}
</pre></div><h3><a class="anchor" name="wxjson_tutorial_style_write_comment">
The wxJSONWRITER_WRITE_COMMENTS flag</a></h3>
Comments are not supported by the JSON syntax specifications although many JSON implementation do recognize C/C++ comment strings. The wxJSON library also recognizes and stores C/C++ comments when a JSON text is read and is also capable to write comments. To know more about comments see <a class="el" href="wxjson_tutorial.html#wxjson_tutorial_comment">Using comment lines in wxJSON</a>.<p>
Unlike in older 0.x versions, this flag does not depend on the wxJSONWRITER_STYLED flag. Comments may be added to the JSON text output even if indentation is suppressed. Because C++ comments rely on the LF character to mark their end, a LF character is always added to the end of a C++ comment and ti cannot be suppressed even if you specify the wxJSONWRITER_NO_LINEFEEDS flag.<p>
Example using only this flag: <div class="fragment"><pre class="fragment">{ <span class="stringliteral">"key1"</span> : <span class="stringliteral">"value1"</span>, <span class="comment">// C++ comment cause the LF char to be written</span>
<span class="stringliteral">"key2"</span> : { <span class="stringliteral">"key2-1"</span> : 12 } <span class="comment">/* C-style comment */</span> }
</pre></div><p>
Comments in JSON text are normally used for debugging purposes and, in general, because a human has to read them so the most common use of this flag is toghether with wxJSONREADER_STYLED:<p>
<div class="fragment"><pre class="fragment">{
    <span class="stringliteral">"key1"</span> : <span class="stringliteral">"value1"</span>, <span class="comment">// C++ comment always include a trailing LF</span>
    <span class="stringliteral">"key2"</span> : {
        <span class="stringliteral">"key2-1"</span> : 12 <span class="comment">/* C-style comment */</span>
    }
}
</pre></div><p>
Note that the wxJSON writer only writes one LF character between the first value and the second one. Because wxJSONWRITER_STYLED prints a LF between values and the C++ comment already terminates with a LF, the writer checks that a LF char was already written before writing the final LF that separates values.<p>
The same applies for C-style comments: they do not need a terminating LF character but you can store it in the comment string: moreover, you can store more than one of them. Before writing the LF character that separates the values, the writer checks if the last character written is a LF: it is it, the final LF is not needed so it is omitted.<h3><a class="anchor" name="wxjson_tutorial_style_comment_before">
The wxJSONWRITER_COMMENT_BEFORE flag</a></h3>
<h3><a class="anchor" name="wxjson_tutorial_style_comment_after">
The wxJSONWRITER_COMMENT_AFTER flag</a></h3>
The two syles are mutually exclusive and only have effect if wxJSONWRITER_WRITE_COMMENTS is also specified. If not, they are simply ignored. The flags cause the writer to always write comments before or after the value they refer to regardless the position of the comments specified in the <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object. The following is an example using wxJSONWRITER_COMMENTS_BEFORE and the <b>styled</b> flag:<p>
<div class="fragment"><pre class="fragment">{
    <span class="comment">// C++ comment always include a trailing LF</span>
    <span class="stringliteral">"key1"</span> : <span class="stringliteral">"value1"</span>,
    <span class="stringliteral">"key2"</span> : {
         <span class="comment">/* C-style comment */</span>
        <span class="stringliteral">"key2-1"</span> : 12
    }
}
</pre></div><p>
Note that comments that are not written <b>inline</b> are indented using the same number of TABs (or spaces) of the value they refer to.<h3><a class="anchor" name="wxjson_tutorial_style_split">
The wxJSONWRITER_SPLIT_STRINGS flag</a></h3>
This feature allows a JSON string to be splitted in two or more lines when a string value is written to JSON text. Consider the following example:<p>
<div class="fragment"><pre class="fragment"> {
    <span class="stringliteral">"copyright"</span> : <span class="stringliteral">"This library is distributed\nunder the GNU Public License\n(C) 2007 XYZ Software"</span>
 }
</pre></div><p>
It would be by far more human readable if it would be written in the following way:<p>
<div class="fragment"><pre class="fragment"> {
    <span class="stringliteral">"copyright"</span> : <span class="stringliteral">"This library is distributed\n"</span>
                  <span class="stringliteral">"under the GNU Public License\n"</span>
                  <span class="stringliteral">"(C) 2007 XYZ Software"</span>
 }
</pre></div><p>
Note that the escaped LF characters at the end of a line is enforced by splitting the string value into two or more indented lines of text as we would normally do in C/C++ sources. The <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> is capable to read such strings but you have to be aware that this is not valid JSON text and other parser may report an error. This flag has no effect if wxJSONWRITER_STYLED is not set. Note that the output text is not strict JSON: the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> class is capable to read strings that are splitted in two or more lines but other JSON implementations may fail to recognize the generated text. Also note that the wxJSON reader class has to be constructed with a flag that does not consider splitted strings as errors.<p>
In order to recognize such strings, the reader concatenates string values (that is values enclosed in double quotes) if a comma separator is not present. Note that only strings can be splitted into more than one line: numbers and literals cannot be splitted. The drawback is that this feature is error-prone. Consider the following example: <div class="fragment"><pre class="fragment">  {
    <span class="stringliteral">"seasons"</span> :  [
      <span class="stringliteral">"spring"</span>,
      <span class="stringliteral">"summer"</span>
      <span class="stringliteral">"autumn"</span>,
      <span class="stringliteral">"winter"</span>
     ]
  }
</pre></div><p>
The array has four elements but I forgot the comma character between the second and the third element. What I get in this case is a three-elements array where the second element is the concatenation of the two strings "summer" and "autumn" which is not what I wanted. Worse, the parser does not consider this an error: only a warning is reported if the parser is constructed with the wxJSONREADER_MULTISTRING flag.<h3><a class="anchor" name="wxjson_tutorial_style_multi">
The wxJSONWRITER_MULTILINE_STRING flag</a></h3>
This is a multiline string mode where newlines and tabs are not escaped. This is not valid JSON text but it helps immensely when manually editing JSON files that contains multiline strings. In the example above the JSON text output will be as follows:<p>
<div class="fragment"><pre class="fragment"> {
    <span class="stringliteral">"copyright"</span> : <span class="stringliteral">"This library is distributed</span>
<span class="stringliteral">under the GNU Public License</span>
<span class="stringliteral">(C) 2007 XYZ Software"</span>
 }
</pre></div><h3><a class="anchor" name="wxjson_tutorial_style_unsigned">
The wxJSONWRITER_RECOGNIZE_UNSIGNED flag</a></h3>
When the wxJSON parser reads a JSON text and enconters a string that apears as a number which value is between INT64_MIN and INT64_MAX ( or LONG_MIN and LONG_MAX if 64-bits support is disabled) it stores the value as a signed integer. For example, the numeric value 100 is read as a signed integer data type even if it was written from a <a class="el" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> object that held a unsigned integer (for example a counter). This is the code:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v[ _T(<span class="stringliteral">"counter"</span>)] = (<span class="keywordtype">unsigned</span> int) 100;
  <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer;
  wxString     jsonText;
  writer.<a class="code" href="classwxJSONWriter.html#2cebc74d641090c6946dac631b782f2e" title="Write the JSONvalue object to a JSON text.">Write</a>( v, jsonText );

  <span class="comment">// the output is:</span>
  {
    <span class="stringliteral">"counter"</span> : 100
  }
</pre></div><p>
The reader cannot know that the variable that generated the value was of type <em>unsigned</em> and it stores the value as a signed integer. In order to force the reader use a unsigned integer in this case, the <a class="el" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> prepends a plus sign to the integer value:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v[ _T(<span class="stringliteral">"counter"</span>)] = (<span class="keywordtype">unsigned</span> int) 100;
  <a class="code" href="classwxJSONWriter.html" title="The JSON document writer.">wxJSONWriter</a> writer( <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5abaf43134ca3b47dd2dc69176da2153c">wxJSONWRITER_RECOGNIZE_UNSIGNED</a> );
  wxString     jsonText;
  writer.<a class="code" href="classwxJSONWriter.html#2cebc74d641090c6946dac631b782f2e" title="Write the JSONvalue object to a JSON text.">Write</a>( v, jsonText );

  <span class="comment">// the output is:</span>
  {
    <span class="stringliteral">"counter"</span> : +100
  }
</pre></div><p>
Now the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> class assigns the value to a <b>unsigned</b> integer data type. Note that this feature is not strict JSON and may be handled incorrectly by other JSON mplementations so, by default, this feature is disabled; you have to use a special wxJSONWriter's flag to get this. Also note that other JSON implementations may fail to read such integers: you should only use the feature if your applications only use the <b>wxJSON</b> library for reading JSON text.<h2><a class="anchor" name="wxjson_tutorial_error">
Error reporting in the parser</a></h2>
When you read a JSON text using the <a class="el" href="classwxJSONReader.html#d5c6e801d57bb3457684c49fdff39758" title="Parse the JSON document.">wxJSONReader::Parse()</a> function, the parser stores in the class's data members two arrays of strings: one for the errors and one for the warnings. Warnings are reported for the wxJSON extensions: if extensions are OFF, warnings are reported as errors. You get the error's and warning's arrays using the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> memberfunctions.<p>
The string that describes the error / warning contains the line and column number of the unrecognized text. The following is an example (line numbers are added in this documentation but does not apear in the real input text<p>
<div class="fragment"><pre class="fragment">The JSON input text (<span class="keyword">this</span> line is ignored by the parser)
 1 {
 2    <span class="stringliteral">"book"</span> :
 3    / seems a C++ comment (forgot slash)
 4    {
 5       <span class="stringliteral">"title"</span>  : <span class="stringliteral">"The title"</span>, ,
 6       <span class="stringliteral">"author"</span> : <span class="stringliteral">"Captain Hook"</span>
 7       pages      : 300,
 8       <span class="stringliteral">"pages2"</span> : abc300,
 9       <span class="stringliteral">"price"</span>  : 30.30,
10       <span class="stringliteral">"price2"</span> : 30.30abc,
11       <span class="stringliteral">"price3"</span>  30,
12       <span class="stringliteral">"translations"</span> :
13        [
14           <span class="stringliteral">"italian"</span>,,
15           <span class="stringliteral">"german"</span>,
16           <span class="stringliteral">"spanish"</span>,
17           <span class="stringliteral">"spanish2"</span> : 
18        }
19   }
20
</pre></div><p>
The array of errors and warnings is as follows:<p>
<div class="fragment"><pre class="fragment">Error: line 3, col 6 - Strange <span class="charliteral">'/'</span> (did you want to insert a comment?)
Error: line 5, col 33 - key or value is missing <span class="keywordflow">for</span> JSON value
Error: line 7, col 14 - Value <span class="stringliteral">'pages'</span> cannot follow a value: <span class="charliteral">','</span> or <span class="charliteral">':'</span> missing?
Error: line 7, col 20 - <span class="charliteral">':'</span> not allowed where a <span class="stringliteral">'name'</span> <span class="keywordtype">string</span> was already available
Error: line 7, col 25 - Value <span class="stringliteral">'300'</span> cannot follow a value: <span class="charliteral">','</span> or <span class="charliteral">':'</span> missing?
Error: line 8, col 26 - Value <span class="stringliteral">'abc300'</span> is incorrect (did you forget quotes?)
Error: line 8, col 26 - cannot store the value: <span class="stringliteral">'value'</span> is missing <span class="keywordflow">for</span> JSON <span class="keywordtype">object</span> type
Error: line 10, col 28 - Value <span class="stringliteral">'30.30abc'</span> is incorrect (did you forget quotes?)
Error: line 10, col 28 - cannot store the value: <span class="stringliteral">'value'</span> is missing <span class="keywordflow">for</span> JSON <span class="keywordtype">object</span> type
Error: line 11, col 21 - Value <span class="stringliteral">'30'</span> cannot follow a value: <span class="charliteral">','</span> or <span class="charliteral">':'</span> missing?
Error: line 11, col 21 - cannot store the value: <span class="stringliteral">'key'</span> is missing <span class="keywordflow">for</span> JSON <span class="keywordtype">object</span> type
Error: line 14, col 23 - key or value is missing <span class="keywordflow">for</span> JSON value
Error: line 17, col 24 - <span class="charliteral">':'</span> can only used in <span class="keywordtype">object</span><span class="stringliteral">'s values</span>
<span class="stringliteral">Warning: line 18, col 10 - Trying to close an array using the '</span>}<span class="stringliteral">' (close-object) char</span>
<span class="stringliteral">Warning: line 21, col 1 - '</span>}<span class="stringliteral">' missing at end of file</span>
</pre></div><p>
In this example the <a class="el" href="classwxJSONReader.html" title="The JSON parser.">wxJSONReader</a> was constructed with the wxJSONREADER_TOLERANT flag. If the wxJSONREADER_STRICT was used, the two warning messages at the end of the output would be errors instead of warnings.<h2><a class="anchor" name="wxjson_tutorial_stdstr">
wxJSON and the std::string</a></h2>
Some wxJSON's users wrote to me to have an implementation of wxJSON that works with <b>std::string</b> strings.<p>
The issue when using wxJSON is that the parser stores strings in <b>wxString</b> objects which has to be converted to <b>std::string</b>. If the input is from a UTF-8 stream, the string goes through a double, sometimes unnecessary, conversion:<p>
<ul>
<li>from UTF-8 to wxString </li>
<li>from wxString to std::string</li>
</ul>
Also note that the internal encoding of <b>std::string</b> on some platforms is UTF-8 so you can understand that the final encoding is the same as the first one!<p>
The hint of these users is: "who cares about internal encoding of strings? Just copy the UTF-8 buffer to the wxString object and let the user do the necessary conversion if needed".<p>
Well, I think this is not a good idea. The purpose of having <b>wxJSON</b> is, of course, to let data be easily accessible from within <b>wxWidgets</b>. Because wxWidgets uses <b>wxString</b> intensively, you can undestand that wxJSON has to store string values in wxString and that they has to be stored in the native encoding in order to be easily accessed, processed and manipulated.<p>
I cannot find a good solution for this issue and if some of you will have a good idea, let me know but remember the main purpose of <b>wxJSON:</b> it was written for <b>wxWidgets</b> and not for the <b>stdlibc++</b> library. </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 7 22:40:56 2010 for wxJSON by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
