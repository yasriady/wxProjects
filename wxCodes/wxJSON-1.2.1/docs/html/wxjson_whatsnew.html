<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>wxJSON: wxJSON - The wxWidgets implementation of JSON</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="wxjson_whatsnew">What's new in version 1.1 </a></h1><h2><a class="anchor" name="json_ver11_wxw29">
Compatible with both wxWidgets 2.8 and 2.9</a></h2>
The new version is compatible with both wxWidgets 2.8 and 2.9. Tried using wxGTK 2.8.10 and 2.9.1 (daily snapshot wxWidgets-2009-10-17)<h2><a class="anchor" name="json_ver11_asfunct">
A new AsXxxxxx() function</a></h2>
The <code>wxJSONValue::AsXxxxx()</code> function can be used to get the value of a JSON value but you have first to check if it is of the expected type. So you would probably write code like this one:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v[<span class="stringliteral">"key"</span>] = 100;
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">if</span> ( v[<span class="stringliteral">"key"</span>].<a class="code" href="classwxJSONValue.html#2872aee9886b348ac438e758d0f9bf18" title="Return TRUE if the type of the value stored is integer.">IsInt</a>() ) {
    i = v[<span class="stringliteral">"key"</span>].<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>();
  }
  <span class="keywordflow">else</span> {
    cout &lt;&lt; <span class="stringliteral">"Error: value is not of the expected type"</span>;
  }
</pre></div><p>
This release adds a new version of all overloaded AsXxxxxx() function which stores the value in the provided argument and returns TRUE if the value stored in the JSON value object is of the correct type. This is the function prototype for integer value: <div class="fragment"><pre class="fragment">  <span class="keywordtype">bool</span> <a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>( <span class="keywordtype">int</span>&amp; i );
</pre></div><p>
Now you can get the value and check if it is of the expected type in only one call:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="classwxJSONValue.html" title="The JSON value class implementation.">wxJSONValue</a> v[<span class="stringliteral">"key"</span>] = 100;
  <span class="keywordtype">int</span> i;
  <span class="keywordflow">if</span> ( !v[<span class="stringliteral">"key"</span>].<a class="code" href="classwxJSONValue.html#9223209e7eea4dd4d668869b69560acb" title="Return the stored value as an integer.">AsInt</a>( i ) ) {
    cout &lt;&lt; <span class="stringliteral">"Error: value is not of the expected type"</span>;
  }
</pre></div><h2><a class="anchor" name="json_ver11_readwrite">
The new reader and writer organizaion</a></h2>
Until version 1.0 the <b>wxJSON</b> reader and writer had some issues mostly related to speed. The problem was that both the reader and the writer performed a character conversion from / to UTF-8 and unicode for every char read from / written to streams. Worst, in ANSI builds, every char undergoes to a double conversion for both the reader and the writer (the following is for the reader):<p>
<ul>
<li>from UTF-8 to <b>wchar_t</b> </li>
<li>from <b>wchar_t</b> to locale dependent <b>char</b> </li>
</ul>
Also note that such a conversion is, for most characters, not needed at all because those chars are in the US-ASCII charset (0x00..0x7F).<p>
In version 3.0 of the GUI framework, developers have introduced a radical change to Unicode support and the <b>wxString</b> class has totally changed in its internal organisation. In particular, the <b>wxString</b> class now stores strings in UTF-16 encoding on Windows and in UTF-8 on unix systems. The drawback is that on *nix systems the usual character access using subscripts such as:<p>
<div class="fragment"><pre class="fragment">    wxString s;
    s[n];
</pre></div><p>
is VERY inefficient because of the UTF-8 encoding. The conseguence is that in wxJSON there is a speed issue also when the JSON text input is from <b>wxString</b> and not only from streams.<h3><a class="anchor" name="json_ver11_goals">
What are the goals of the new 1.1 version</a></h3>
In order to find the best organization for the reader and the writer I have to first point out what are the goals of this new release of wxJSON:<p>
<ul>
<li>compatibility with wxWidgets 2.8 and 2.9</li>
</ul>
<ul>
<li>compatibility with wxJSON version 1.0: I do not want to break the compatibility with 1.0 version otherwise I will have to change the major version number</li>
</ul>
<ul>
<li>speed improvements: I will try to speed-up both the reader and the writer. The conversion of <b>each</b> character is very slow; there are better solutions as pointed out by Piotr Likus in his e-mail of november 2008</li>
</ul>
<ul>
<li>simplicity: JSON format is very easy to read and write for humans but it is also easy for machines to parse and generate. The wxJSON library has to be simple in the processing of JSON text.</li>
</ul>
<h3><a class="anchor" name="json_ver11_solution">
The new wxJSON organisation</a></h3>
The <b>wxJSON</b> library allows you to write / read JSON text to / from two different types of objects:<p>
<ul>
<li>a string of type <code>wxString</code> </li>
<li>a stream of type <code>wxInput/OutputStream</code> </li>
</ul>
These two kinds of I/O classes are very different because of the internal representation of the JSON text: in particular, wxString uses UTF-16 on windows and UTF-32 on *nix systems up to <b>wxWidgets</b> <b>2.8</b>. UTF-8 is used on *nix systems in <code>wxWidgets</code> <code>2.9</code>. For streams the encoding is alwasy UTF-8. A further different encoding is used in ANSI mode: locale dependent one-byte characters.<p>
<dl class="user" compact><dt><b>Encoding formats in the different wxWidget's modes / versions /platforms</b></dt><dd></dd></dl>
<div align="center">
<img src="images/ver11.gif" alt="ver11.gif">
</div>
<p>
These encoding differences complicates very much the organization of the writer and the reader because character read from / written to JSON text has to be converted to a unique type for processing. Actually, each char is converted to a <b>wchar_t</b> type and it occurs in ANSI mode, too. This conversion slows down the processing very much. A further complication is that <b>wxWidgets</b> 2.9 does no more return a <b>char</b> or <b>wchar_t</b> type when accessing string objects but a helper class: <b>wxUniChar</b> which has its own encoding format so that it has to be further converted to <b>wchar_t</b>.<p>
The solution is to use only one encoding format for <b>all</b> types of I/O, build mode and wxWidget's versions: UTF-8 is the only one applicable to all these cases. Using UTF-8 as the unique I/O format has several advantages:<p>
<ul>
<li>UTF-8 does not have endianness or byte order issues</li>
</ul>
<ul>
<li>the pocessing of characters is <em>byte-oriented</em> so there is no need to deal with <b>wchar_t</b> or <b>wxUniChar:</b> special JSON characters, literal and numbers lie in the US-ASCII character set (one UTF-8 code unit).</li>
</ul>
<ul>
<li>the read operation of string values is easy: when a double-quote byte is encontered, the UTF-8 stream is simply <b>copied</b> to a temporary memory buffer until the next unescaped double-quote char (we just process escaped chars). When the buffer has been read, it is converted in one single step to <b>wxString</b> using <code>wxString::FromUTF8()</code> function.</li>
</ul>
<ul>
<li>the write operation of strings is easy: the <b>wxString</b> value is converted to a temporary UTF-8 memory buffer using the static <b>wxString::ToUTF8()</b> function. The bytes are then written to the UTF-8 stream: we only have to process control chars and escaped characters.</li>
</ul>
<ul>
<li>from the point of view of the processing, there is no difference between ANSI and Unicode because the processing is byte-oriented.</li>
</ul>
The only drawback is when input / output is not from / to a stream (which is in UTF-8 format) but from / to a <b>wxString</b> object. The solution I found is:<p>
<ul>
<li>when input is from a string object, the reader first convert the <b>wxString</b> JSON text input in a temporary UTF-8 memory buffer which is used to construct a <b>wxMemoryInputStream</b> object</li>
</ul>
<ul>
<li>when output is to be sent to a string object, the writer first construct a temporary empty <b>wxMemoryOutputStream</b> which holds the JSON text output. When the write operation is done, the temporary memory buffer is converted to a <b>wxString</b> object using the <b>wxString::FormUTF8()</b> function.</li>
</ul>
So, as opposed to the previous versions, the read / write operations are faster on streams and slower on strings because of the construction of the temporary UTF-8 memory buffers.<h3><a class="anchor" name="json_ver11_ansiread">
New feature in ANSI mode</a></h3>
The default behaviour of the <b>wxJSON</b> library in ANSI builds when reading from / writing to streams is to use UTF-8 encoded text so that the writer produces valid JSON text and the reader gives some limited Unicode support (see <a class="el" href="wxjson_tutorial.html#wxjson_tutorial_unicode_ansi">Unicode support: ANSI builds</a> for details).<p>
In version 1.1 I introduced a new feature for ANSI builds: both the reader and the writer can be constructed with a special flag:<p>
<div class="fragment"><pre class="fragment">  <a class="code" href="jsonreader_8h.html#06fc87d81c62e9abb8790b6e5713c55b61cd42579e05db62b2a3db6f410a5e7a">wxJSONREADER_NOUTF8_STREAM</a>
  <a class="code" href="jsonwriter_8h.html#99fb83031ce9923c84392b4e92f956b5887ce7589fbc9ff78c81bd9ad7615bc1">wxJSONWRITER_NOUTF8_STREAM</a>
</pre></div><p>
that suppress UTF-8 conversion:<p>
<ul>
<li>the writer produces ANSI JSON text which can be correctly read by the application that wrote it provided that it is localized in the same locale </li>
<li>the reader does not try to convert the JSON text input from UTF-8 because it suppose that the text is stored in ANSI format.</li>
</ul>
The advantage of this ANSI mode is speed: string's data is simply copied from the stream to <b>wxString</b> by the reader; JSON values containing string are simply copied from the <b>wxString</b> object to the stream by the writer.<p>
Also note that this feature can be used also if the stream is in UTF-8 format. By suppressing UTF-8 conversion the reader copies all UTF-8 code units in the <b>wxString</b> object: naturally, the meaning of those code-units are misunderstood by the wxString object which treats them as locale dependent one-byte characters: the advantage is that writing them back in ANSI mode just preserve the UTF-8 encoding because each UTF-8 code-unit is simply <b>copied</b> to the stream. The drawback is that the UTF-8 stream read by the wxJSON reader may contain characters that <b>can</b> be represented in the current locale. If UTF-8 conversion is disabled in the reader, no conversion takes place.<p>
For example: suppose that in a UTF-8 input stream there is the following string:<p>
<div class="fragment"><pre class="fragment">  C3 A0 C3 A8 C3 AC C2 A9 C2 AE
</pre></div><p>
which has to following meaning (five characters, ten UTF-8 code-units)<p>
<div class="fragment"><pre class="fragment">  àèì©®
</pre></div><p>
The character's meaning could be correcly interpreted in an ANSI application localized in a Latin-1 charset If UTF-8 conversion is not disabled, the wxJSON reader reads the five Latin-1 characters correctly. On the other hand, if UTF-8 conversion is disabled, the ten UTF-8 code-units are simply copied to the <b>wxString</b> object which contains 10 characters whose meaning (in ths ISO-8859-1 charset) is the following:<p>
<div class="fragment"><pre class="fragment">  Ã Ã¨Ã¬Â©Â®
</pre></div> </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Jan 7 22:40:56 2010 for wxJSON by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
